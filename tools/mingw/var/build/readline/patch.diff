diff -urbBN readline-4.2/bind.c readline/bind.c
--- readline-4.2/bind.c	Mon Mar  5 15:10:06 2001
+++ readline/bind.c	Fri Jul 27 17:20:32 2001
@@ -48,6 +48,11 @@
 extern int errno;
 #endif /* !errno */
 
+#ifdef __MINGW32__
+#include <sys/stat.h>
+#include <io.h>
+#endif
+
 #include "posixstat.h"
 
 /* System-specific feature definitions and include files. */
@@ -698,6 +703,10 @@
   return (_rl_read_init_file (filename, 0));
 }
 
+#ifdef __MINGW32__
+extern char *get_user_registry_string(char *keyName, char* valName);
+#endif
+
 static int
 _rl_read_init_file (filename, include_level)
      const char *filename;
@@ -713,6 +722,18 @@
   openname = tilde_expand (filename);
   buffer = _rl_read_file (openname, &file_size);
   free (openname);
+
+#if defined (__MINGW32__) && defined (INITFILES_IN_REGISTRY)
+  if (buffer == 0)
+    {
+      openname = get_user_registry_string(READLINE_REGKEY, INPUTRC_REGVAL);
+      if (openname)
+        {
+          buffer = _rl_read_file (openname, &file_size);
+          free (openname);
+        }
+    }
+#endif	/* __MINGW32__ */
 
   if (buffer == 0)
     return (errno);
diff -urbBN readline-4.2/callback.c readline/callback.c
--- readline-4.2/callback.c	Tue Dec 12 19:48:20 2000
+++ readline/callback.c	Fri Jul 27 17:20:32 2001
@@ -31,6 +31,7 @@
 
 #include <sys/types.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
diff -urbBN readline-4.2/chardefs.h readline/chardefs.h
--- readline-4.2/chardefs.h	Wed Sep 13 23:20:14 2000
+++ readline/chardefs.h	Fri Jul 27 17:20:32 2001
@@ -46,10 +46,17 @@
 /* Some character stuff. */
 #define control_character_threshold 0x020   /* Smaller than this is control. */
 #define control_character_mask 0x1f	    /* 0x20 - 1 */
-#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
 #define control_character_bit 0x40	    /* 0x000000, must be off. */
+
+#ifndef __MINGW32__
+#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
 #define meta_character_bit 0x080	    /* x0000000, must be on. */
 #define largest_char 255		    /* Largest character value. */
+#else
+#define meta_character_threshold 0x0ff	    /* Larger than this is Meta. */
+#define meta_character_bit 0x100	    /* x0000000, must be on. */
+#define largest_char 0x1ff		    /* Largest character value. */
+#endif
 
 #define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))
 #define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
diff -urbBN readline-4.2/compat.c readline/compat.c
--- readline-4.2/compat.c	Tue Feb  6 19:15:12 2001
+++ readline/compat.c	Fri Jul 27 19:51:14 2001
@@ -29,6 +29,7 @@
 
 #include "rlstdc.h"
 #include "rltypedefs.h"
+#include "readline.h"
 
 extern void rl_free_undo_list __P((void));
 extern int rl_maybe_save_line __P((void));
diff -urbBN readline-4.2/complete.c readline/complete.c
--- readline-4.2/complete.c	Wed Feb 14 12:47:18 2001
+++ readline/complete.c	Fri Jul 27 18:18:08 2001
@@ -42,13 +42,19 @@
 #endif /* HAVE_STDLIB_H */
 
 #include <stdio.h>
+#ifdef __MINGW32__
+# include <windows.h>
+# include <io.h>
+#endif
 
 #include <errno.h>
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
+#ifndef __MINGW32__
 #include <pwd.h>
+#endif
 
 #include "posixdir.h"
 #include "posixstat.h"
@@ -1398,7 +1404,12 @@
   return (char *)NULL;
 #else /* !__WIN32__ && !__OPENNT) */
   static char *username = (char *)NULL;
+#ifndef __MINGW32__
   static struct passwd *entry;
+#else
+  char UserName[128];
+  unsigned UserLen;
+#endif
   static int namelen, first_char, first_char_loc;
   char *value;
 
@@ -1411,9 +1422,12 @@
 
       username = savestring (&text[first_char_loc]);
       namelen = strlen (username);
+#ifndef __MINGW32__
       setpwent ();
+#endif
     }
 
+#ifndef __MINGW32__
   while (entry = getpwent ())
     {
       /* Null usernames should result in all users as possible completions. */
@@ -1439,6 +1453,21 @@
 
       return (value);
     }
+#else /* __MINGW32__ */
+  if (GetUserName (UserName, &UserLen))
+    {
+      if (namelen == 0 || (!strnicmp (username, UserName, namelen)))
+	{
+	  value = xmalloc (2 + strlen (UserName));
+	  *value = *text;
+	  strcpy (value + first_char_loc, UserName);
+	  if (first_char == '~')
+	    rl_filename_completion_desired = 1;
+	  return (value);
+	}
+    }
+  return ((char *)NULL);
+#endif /* __MINGW32__ */
 #endif /* !__WIN32__ && !__OPENNT */
 }
 
@@ -1451,14 +1480,22 @@
      const char *text;
      int state;
 {
+#ifdef __MINGW32__
+  static WIN32_FIND_DATA entry;
+  static HANDLE directory = NULL;
+  static BOOL found = 0;
+  char tmp[MAX_PATH];
+# define DIR void
+#else
+  struct dirent *entry;
   static DIR *directory = (DIR *)NULL;
+#endif
   static char *filename = (char *)NULL;
   static char *dirname = (char *)NULL;
   static char *users_dirname = (char *)NULL;
   static int filename_len;
   char *temp;
   int dirlen;
-  struct dirent *entry;
 
   /* If we don't have any state, then do some initialization. */
   if (state == 0)
@@ -1527,7 +1564,18 @@
 	  users_dirname = savestring (dirname);
 	}
 
+#ifdef __MINGW32__
+      strcpy (tmp, dirname);
+      if (tmp[strlen (tmp) - 1] == '/')
+	strcat (tmp, "*");
+      else
+	strcat (tmp, "/*");
+	
+      directory = FindFirstFile (tmp, &entry);
+      found = 1;
+#else  
       directory = opendir (dirname);
+#endif
       filename_len = strlen (filename);
 
       rl_filename_completion_desired = 1;
@@ -1540,17 +1588,20 @@
   /* *** UNIMPLEMENTED *** */
 
   /* Now that we have some state, we can read the directory. */
-
+#ifndef __MINGW32__
   entry = (struct dirent *)NULL;
   while (directory && (entry = readdir (directory)))
+#else
+  while (directory != INVALID_HANDLE_VALUE && directory && found)
+#endif
     {
       /* Special case for no filename.
 	 All entries except "." and ".." match. */
       if (filename_len == 0)
 	{
-	  if (entry->d_name[0] != '.' ||
-	       (entry->d_name[1] &&
-		 (entry->d_name[1] != '.' || entry->d_name[2])))
+	  if (FILENAME(entry)[0] != '.' ||
+	      (FILENAME(entry)[1] &&
+	       (FILENAME(entry)[1] != '.' || FILENAME(entry)[2])))
 	    break;
 	}
       else
@@ -1559,22 +1610,29 @@
 	     it is a match. */
 	  if (_rl_completion_case_fold)
 	    {
-	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
+	      if ((_rl_to_lower (FILENAME(entry)[0]) == _rl_to_lower (filename[0])) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
+		  (_rl_strnicmp (filename, FILENAME(entry), filename_len) == 0))
 		break;
 	    }
 	  else
 	    {
-	      if ((entry->d_name[0] == filename[0]) &&
+	      if ((FILENAME(entry)[0] == filename[0]) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (strncmp (filename, entry->d_name, filename_len) == 0))
+		  (strncmp (filename, FILENAME(entry), filename_len) == 0))
 		break;
 	    }
 	}
+#ifdef __MINGW32__
+      found = FindNextFile (directory, &entry);
+#endif    
     }
 
+#ifdef __MINGW32__
+  if (!found)
+#else
   if (entry == 0)
+#endif
     {
       if (directory)
 	{
@@ -1627,11 +1685,14 @@
 		temp[dirlen++] = '/';
 	    }
 
-	  strcpy (temp + dirlen, entry->d_name);
+	  strcpy (temp + dirlen, FILENAME(entry));
 	}
       else
-	temp = savestring (entry->d_name);
+	temp = savestring (FILENAME(entry));
 
+#ifdef __MINGW32__
+      found = FindNextFile (directory, &entry);
+#endif
       return (temp);
     }
 }
diff -urbBN readline-4.2/config.h readline/config.h
--- readline-4.2/config.h	Thu Jan  1 01:00:00 1970
+++ readline/config.h	Fri Jul 27 17:20:32 2001
@@ -0,0 +1,149 @@
+/* config.h.  Generated automatically by configure.  */
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define if on MINIX.  */
+/* #undef _MINIX */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* #undef STAT_MACROS_BROKEN */
+
+#define VOID_SIGHANDLER 1
+
+/* Define if you have the lstat function. */
+/* #undef HAVE_LSTAT */
+
+/* Define if you have the memmove function. */
+#define HAVE_MEMMOVE 1
+
+/* Define if you have the putenv function.  */
+#define HAVE_PUTENV 1
+
+/* Define if you have the select function.  */
+/* #undef HAVE_SELECT */
+
+/* Define if you have the setenv function.  */
+/* #undef HAVE_SETENV */
+
+/* Define if you have the strcasecmp function.  */
+/* #undef HAVE_STRCASECMP */
+
+/* Define if you have the setlocale function. */
+#define HAVE_SETLOCALE 1
+
+/* Define if you have the tcgetattr function.  */
+/* #undef HAVE_TCGETATTR */
+
+/* Define if you have the strcoll function.  */
+#define HAVE_STRCOLL 1
+
+#define STRCOLL_BROKEN 1
+
+/* Define if you have the <dirent.h> header file.  */
+/* #undef HAVE_DIRENT_H */
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <stdlib.h> header file.  */
+#define HAVE_STDLIB_H 1
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if you have the <sys/file.h> header file.  */
+/* #undef HAVE_SYS_FILE_H */
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/pte.h> header file.  */
+/* #undef HAVE_SYS_PTE_H */
+
+/* Define if you have the <sys/ptem.h> header file.  */
+/* #undef HAVE_SYS_PTEM_H */
+
+/* Define if you have the <sys/select.h> header file.  */
+/* #undef HAVE_SYS_SELECT_H */
+
+/* Define if you have the <sys/stream.h> header file.  */
+/* #undef HAVE_SYS_STREAM_H */
+
+/* Define if you have the <termcap.h> header file.  */
+/* #undef HAVE_TERMCAP_H */
+
+/* Define if you have the <termio.h> header file.  */
+/* #undef HAVE_TERMIO_H */
+
+/* Define if you have the <termios.h> header file.  */
+/* #undef HAVE_TERMIOS_H */
+
+/* Define if you have the <unistd.h> header file.  */
+/* #undef HAVE_UNISTD_H */
+
+/* Define if you have the <varargs.h> header file.  */
+#define HAVE_VARARGS_H 1
+
+/* Define if you have the <stdarg.h> header file.  */
+#define HAVE_STDARG_H 1
+
+#define HAVE_LOCALE_H 1
+
+/* Definitions pulled in from aclocal.m4. */
+#define VOID_SIGHANDLER 1
+
+/* #undef GWINSZ_IN_SYS_IOCTL */
+
+/* #undef STRUCT_WINSIZE_IN_SYS_IOCTL */
+
+/* #undef STRUCT_WINSIZE_IN_TERMIOS */
+
+/* #undef TIOCSTAT_IN_SYS_IOCTL */
+
+/* #undef FIONREAD_IN_SYS_IOCTL */
+
+/* #undef SPEED_T_IN_SYS_TYPES */
+
+#define HAVE_GETPW_DECLS 1
+
+/* #undef STRUCT_DIRENT_HAS_D_INO */
+
+/* #undef STRUCT_DIRENT_HAS_D_FILENO */
+
+/* #undef HAVE_BSD_SIGNALS */
+
+/* #undef HAVE_POSIX_SIGNALS */
+
+/* #undef HAVE_USG_SIGHOLD */
+
+#define MUST_REINSTALL_SIGHANDLERS 1
+
+/* #undef HAVE_POSIX_SIGSETJMP */
+
+/* config.h.bot */
+/* modify settings or make new ones based on what autoconf tells us. */
+
+/* Ultrix botches type-ahead when switching from canonical to
+   non-canonical mode, at least through version 4.3 */
+#if !defined (HAVE_TERMIOS_H) || !defined (HAVE_TCGETATTR) || defined (ultrix)
+#  define TERMIOS_MISSING
+#endif
+
+#if defined (STRCOLL_BROKEN)
+#  define HAVE_STRCOLL 1
+#endif
+
+#if defined (__STDC__) && defined (HAVE_STDARG_H)
+#  define PREFER_STDARG
+#  define USE_VARARGS
+#else
+#  if defined (HAVE_VARARGS_H)
+#    define PREFER_VARARGS
+#    define USE_VARARGS
+#  endif
+#endif
diff -urbBN readline-4.2/display.c readline/display.c
--- readline-4.2/display.c	Fri Feb  2 18:25:10 2001
+++ readline/display.c	Fri Jul 27 18:10:14 2001
@@ -54,6 +54,14 @@
 #include "rlprivate.h"
 #include "xmalloc.h"
 
+#ifdef __MINGW32__
+#include <windows.h>
+extern int haveConsole;
+extern HANDLE hStdout, hStdin;
+extern COORD rlScreenEnd;
+extern int rlScreenMax;
+#endif /* __MINGW32__ */
+
 #if !defined (strchr) && !defined (__STDC__)
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
@@ -63,10 +71,16 @@
 #endif
 
 static void update_line __P((char *, char *, int, int, int, int));
-static void space_to_eol __P((int));
 static void delete_chars __P((int));
 static void insert_some_chars __P((char *, int));
+#ifndef __MINGW32__
+static void space_to_eol __P((int));
 static void cr __P((void));
+#else
+# define cr() _rl_move_cursor_relative (0, 0)
+# define space_to_eol(count) _rl_clear_to_eol (count)
+# define putc(ch, stream) _rl_output_character_function (ch)
+#endif
 
 static int *inv_lbreaks, *vis_lbreaks;
 static int inv_lbsize, vis_lbsize;
@@ -731,6 +745,8 @@
 	    {
 #if defined (__MSDOS__)
 	      putc ('\r', rl_outstream);
+#elif defined (__MINGW32__)
+	      cr ();
 #else
 	      if (_rl_term_cr)
 		tputs (_rl_term_cr, 1, _rl_output_character_function);
@@ -989,6 +1005,8 @@
     {
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
+#elif defined (__MINGW32__)
+      cr ();
 #else
       tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
@@ -1012,6 +1030,7 @@
   temp = ne - nfd;
   if (lendiff > 0)
     {
+#ifndef __MINGW32__
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
       /* Sometimes it is cheaper to print the characters rather than
@@ -1057,6 +1076,7 @@
 	    }
 	}
       else
+#endif /* !__MINGW32__ */
 	{
 	  /* cannot insert chars, write to EOL */
 	  _rl_output_some_chars (nfd, temp);
@@ -1065,6 +1085,7 @@
     }
   else				/* Delete characters from line. */
     {
+#ifndef __MINGW32__
       /* If possible and inexpensive to use terminal deletion, then do so. */
       if (_rl_term_dc && (2 * temp) >= -lendiff)
 	{
@@ -1088,6 +1109,7 @@
 	}
       /* Otherwise, print over the existing material. */
       else
+#endif /* !__MINGW32__ */
 	{
 	  if (temp > 0)
 	    {
@@ -1193,6 +1215,7 @@
 /* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
    DATA is the contents of the screen line of interest; i.e., where
    the movement is being done. */
+#ifndef __MINGW32__
 void
 _rl_move_cursor_relative (new, data)
      int new;
@@ -1277,6 +1300,40 @@
   _rl_last_v_pos = to;		/* Now TO is here */
 }
 
+#else /* __MINGW32__ */
+
+void
+_rl_move_cursor_relative (new, data)
+     int new;
+     const char *data;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if ( (_rl_last_c_pos != new)
+       && haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      csbi.dwCursorPosition.X += new - _rl_last_c_pos;
+      if ( SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition) )
+	_rl_last_c_pos = new;
+    }
+  return;
+}
+ 
+void
+_rl_move_vert (to)
+     int to;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if ( (_rl_last_v_pos != to) && (to <= _rl_screenheight)
+       && haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      csbi.dwCursorPosition.Y += to - _rl_last_v_pos;
+      if ( SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition) )
+	_rl_last_v_pos = to;
+    }
+}
+
+#endif /* __MINGW32__ */
+
 /* Physically print C on rl_outstream.  This is for functions which know
    how to optimize the display.  Return the number of characters output. */
 int
@@ -1475,6 +1532,7 @@
 
 /* Clear to the end of the line.  COUNT is the minimum
    number of character spaces to clear, */
+#ifndef __MINGW32__ /* replace next two functions */
 void
 _rl_clear_to_eol (count)
      int count;
@@ -1499,15 +1557,44 @@
   _rl_last_c_pos += count;
 }
 
+#else	/* __MINGW32__ */
+
+void
+_rl_clear_to_eol (count)
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if (haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi))
+    {
+      DWORD written;
+      int linear_pos;
+      
+      linear_pos = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+	+ (int)csbi.dwCursorPosition.X;
+      if (linear_pos < rlScreenMax)
+	{
+	  rlScreenEnd = csbi.dwCursorPosition;
+	  rlScreenMax = linear_pos;
+	}
+      FillConsoleOutputCharacter(hStdout, ' ', count, csbi.dwCursorPosition, &written);
+    }
+  return;
+}
+
+#endif	/* __MINGW32__ */
+
 void
 _rl_clear_screen ()
 {
+#ifndef __MINGW32__
   if (_rl_term_clrpag)
     tputs (_rl_term_clrpag, 1, _rl_output_character_function);
   else
+#endif
     rl_crlf ();
 }
 
+#ifndef __MINGW32__
 /* Insert COUNT characters from STRING to the output stream. */
 static void
 insert_some_chars (string, count)
@@ -1569,6 +1656,7 @@
 	  tputs (_rl_term_dc, 1, _rl_output_character_function);
     }
 }
+#endif /* !__MINGW32__ */
 
 void
 _rl_update_final ()
@@ -1604,6 +1692,7 @@
   rl_display_fixed++;
 }
 
+#ifndef __MINGW32__
 /* Move to the start of the current line. */
 static void
 cr ()
@@ -1618,6 +1707,7 @@
       _rl_last_c_pos = 0;
     }
 }
+#endif
 
 /* Redraw the last line of a multi-line prompt that may possibly contain
    terminal escape sequences.  Called with the cursor at column 0 of the
@@ -1664,7 +1754,11 @@
      the right thing happens if we have wrapped to a new screen line. */
   if (_rl_term_cr)
     {
-#if defined (__MSDOS__)
+#ifdef __MINGW32__
+      _rl_move_cursor_relative (0, 0);
+      space_to_eol (_rl_screenwidth);
+      _rl_move_cursor_relative (0, 0);
+#elif defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
       tputs (_rl_term_cr, 1, _rl_output_character_function);
@@ -1673,7 +1767,7 @@
 #if defined (__MSDOS__)
       space_to_eol (_rl_screenwidth);
       putc ('\r', rl_outstream);
-#else
+#elif !defined (__MINGW32__)
       if (_rl_term_clreol)
 	tputs (_rl_term_clreol, 1, _rl_output_character_function);
       else
diff -urbBN readline-4.2/examples/fileman.c readline/examples/fileman.c
--- readline-4.2/examples/fileman.c	Tue Dec 12 20:05:24 2000
+++ readline/examples/fileman.c	Fri Jul 27 17:20:32 2001
@@ -299,8 +299,11 @@
 {
   if (!arg)
     arg = "";
-
+#ifdef __MSDOS__
+  sprintf (syscom, "dir %s", arg);
+#else
   sprintf (syscom, "ls -FClg %s", arg);
+#endif
   return (system (syscom));
 }
 
diff -urbBN readline-4.2/examples/fileman.dsp readline/examples/fileman.dsp
--- readline-4.2/examples/fileman.dsp	Thu Jan  1 01:00:00 1970
+++ readline/examples/fileman.dsp	Fri Jul 27 17:20:32 2001
@@ -0,0 +1,65 @@
+# Microsoft Developer Studio Project File - Name="fileman" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 5.00
+# ** NICHT BEARBEITEN **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=fileman - Win32 Debug
+!MESSAGE Dies ist kein gültiges Makefile. Zum Erstellen dieses Projekts mit\
+ NMAKE
+!MESSAGE verwenden Sie den Befehl "Makefile exportieren" und führen Sie den\
+ Befehl
+!MESSAGE 
+!MESSAGE NMAKE /f "fileman.mak".
+!MESSAGE 
+!MESSAGE Sie können beim Ausführen von NMAKE eine Konfiguration angeben
+!MESSAGE durch Definieren des Makros CFG in der Befehlszeile. Zum Beispiel:
+!MESSAGE 
+!MESSAGE NMAKE /f "fileman.mak" CFG="fileman - Win32 Debug"
+!MESSAGE 
+!MESSAGE Für die Konfiguration stehen zur Auswahl:
+!MESSAGE 
+!MESSAGE "fileman - Win32 Debug" (basierend auf\
+  "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Dbg"
+# PROP Intermediate_Dir "Dbg"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "HAVE_CONFIG_H" /D "READLINE_LIBRARY" /D "__READLINE_IMPORT__" /D "__MSDOS__" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib libreadline.lib /nologo /version:4.1 /subsystem:console /pdb:none /debug /machine:I386 /libpath:"../Dbg"
+# Begin Target
+
+# Name "fileman - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\fileman.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\xmalloc.c
+# End Source File
+# End Target
+# End Project
diff -urbBN readline-4.2/examples/rltest.dsp readline/examples/rltest.dsp
--- readline-4.2/examples/rltest.dsp	Thu Jan  1 01:00:00 1970
+++ readline/examples/rltest.dsp	Fri Jul 27 17:20:32 2001
@@ -0,0 +1,61 @@
+# Microsoft Developer Studio Project File - Name="rltest" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 5.00
+# ** NICHT BEARBEITEN **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=rltest - Win32 Debug
+!MESSAGE Dies ist kein gültiges Makefile. Zum Erstellen dieses Projekts mit\
+ NMAKE
+!MESSAGE verwenden Sie den Befehl "Makefile exportieren" und führen Sie den\
+ Befehl
+!MESSAGE 
+!MESSAGE NMAKE /f "rltest.mak".
+!MESSAGE 
+!MESSAGE Sie können beim Ausführen von NMAKE eine Konfiguration angeben
+!MESSAGE durch Definieren des Makros CFG in der Befehlszeile. Zum Beispiel:
+!MESSAGE 
+!MESSAGE NMAKE /f "rltest.mak" CFG="rltest - Win32 Debug"
+!MESSAGE 
+!MESSAGE Für die Konfiguration stehen zur Auswahl:
+!MESSAGE 
+!MESSAGE "rltest - Win32 Debug" (basierend auf\
+  "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Dbg"
+# PROP Intermediate_Dir "Dbg"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "READLINE_LIBRARY" /D "__READLINE_IMPORT__" /D "HAVE_CONFIG_H" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib libreadline.lib /nologo /version:4.1 /subsystem:console /pdb:none /debug /machine:I386 /libpath:"../Dbg"
+# Begin Target
+
+# Name "rltest - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\rltest.c
+# End Source File
+# End Target
+# End Project
diff -urbBN readline-4.2/examples/rlversion.dsp readline/examples/rlversion.dsp
--- readline-4.2/examples/rlversion.dsp	Thu Jan  1 01:00:00 1970
+++ readline/examples/rlversion.dsp	Fri Jul 27 17:20:32 2001
@@ -0,0 +1,63 @@
+# Microsoft Developer Studio Project File - Name="rlversion" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 5.00
+# ** NICHT BEARBEITEN **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=rlversion - Win32 Debug
+!MESSAGE Dies ist kein gültiges Makefile. Zum Erstellen dieses Projekts mit\
+ NMAKE
+!MESSAGE verwenden Sie den Befehl "Makefile exportieren" und führen Sie den\
+ Befehl
+!MESSAGE 
+!MESSAGE NMAKE /f "rlversion.mak".
+!MESSAGE 
+!MESSAGE Sie können beim Ausführen von NMAKE eine Konfiguration angeben
+!MESSAGE durch Definieren des Makros CFG in der Befehlszeile. Zum Beispiel:
+!MESSAGE 
+!MESSAGE NMAKE /f "rlversion.mak" CFG="rlversion - Win32 Debug"
+!MESSAGE 
+!MESSAGE Für die Konfiguration stehen zur Auswahl:
+!MESSAGE 
+!MESSAGE "rlversion - Win32 Debug" (basierend auf\
+  "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Dbg"
+# PROP Intermediate_Dir "Dbg"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I ".." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "READLINE_LIBRARY" /D "__READLINE_IMPORT__" /D "HAVE_CONFIG_H" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib libreadline.lib /nologo /version:4.1 /subsystem:console /pdb:none /debug /machine:I386 /libpath:"../Dbg"
+# Begin Target
+
+# Name "rlversion - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\rlversion.c
+# ADD CPP /MTd
+# SUBTRACT CPP /YX
+# End Source File
+# End Target
+# End Project
diff -urbBN readline-4.2/funmap.c readline/funmap.c
--- readline-4.2/funmap.c	Wed Nov  8 17:38:12 2000
+++ readline/funmap.c	Fri Jul 27 18:24:48 2001
@@ -108,7 +108,7 @@
   { "non-incremental-reverse-search-history", rl_noninc_reverse_search },
   { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
   { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
-#ifdef __CYGWIN__
+#if defined (__CYGWIN__) || defined (__MINGW32__)
   { "paste-from-clipboard", rl_paste_from_clipboard },
 #endif
   { "possible-completions", rl_possible_completions },
diff -urbBN readline-4.2/histfile.c readline/histfile.c
--- readline-4.2/histfile.c	Tue Mar  6 18:14:26 2001
+++ readline/histfile.c	Fri Jul 27 17:20:32 2001
@@ -32,7 +32,7 @@
 #include <stdio.h>
 
 #include <sys/types.h>
-#ifndef _MINIX
+#if HAVE_SYS_FILE_H
 #  include <sys/file.h>
 #endif
 #include "posixstat.h"
@@ -54,12 +54,15 @@
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
+#ifdef __MINGW32__
+#include <io.h>
+#endif
 
 /* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
    on win 95/98/nt), we want to open files with O_BINARY mode so that there
    is no \n -> \r\n conversion performed.  On other systems, we don't want to
    mess around with O_BINARY at all, so we ensure that it's defined to 0. */
-#if defined (__EMX__) || defined (__CYGWIN__)
+#if defined (__EMX__) || defined (__CYGWIN__) || defined (__MINGW32__)
 #  ifndef O_BINARY
 #    define O_BINARY 0
 #  endif
@@ -79,6 +82,11 @@
 #include "rlshell.h"
 #include "xmalloc.h"
 
+#ifdef __MINGW32__
+#include "rldefs.h"
+extern char *get_user_registry_string(char *keyName, char* valName);
+#endif
+
 /* Return the string that should be used in the place of this
    filename.  This only matters when you don't specify the
    filename to read_history (), or write_history (). */
@@ -99,6 +107,12 @@
 
   if (home == 0)
     {
+#if defined (__MINGW32__) && defined (INITFILES_IN_REGISTRY)
+      return_val = get_user_registry_string (READLINE_REGKEY, HISTFILE_REGVAL);
+      if (return_val)
+        return (return_val);
+      free (return_val);
+#endif	/* __MINGW32__ ... */
       home = ".";
       home_len = 1;
     }
diff -urbBN readline-4.2/history.h readline/history.h
--- readline-4.2/history.h	Tue Mar  6 18:54:26 2001
+++ readline/history.h	Fri Jul 27 18:28:14 2001
@@ -22,6 +22,14 @@
 #ifndef _HISTORY_H_
 #define _HISTORY_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -62,81 +70,81 @@
 
 /* Begin a session in which the history functions might be used.  This
    just initializes the interactive variables. */
-extern void using_history __P((void));
+READLINE_API extern void using_history __P((void));
 
 /* Return the current HISTORY_STATE of the history. */
-extern HISTORY_STATE *history_get_history_state __P((void));
+READLINE_API extern HISTORY_STATE *history_get_history_state __P((void));
 
 /* Set the state of the current history array to STATE. */
-extern void history_set_history_state __P((HISTORY_STATE *));
+READLINE_API extern void history_set_history_state __P((HISTORY_STATE *));
 
 /* Manage the history list. */
 
 /* Place STRING at the end of the history list.
    The associated data field (if any) is set to NULL. */
-extern void add_history __P((const char *));
+READLINE_API extern void add_history __P((const char *));
 
 /* A reasonably useless function, only here for completeness.  WHICH
    is the magic number that tells us which element to delete.  The
    elements are numbered from 0. */
-extern HIST_ENTRY *remove_history __P((int));
+READLINE_API extern HIST_ENTRY *remove_history __P((int));
 
 /* Make the history entry at WHICH have LINE and DATA.  This returns
    the old entry so you can dispose of the data.  In the case of an
    invalid WHICH, a NULL pointer is returned. */
-extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
+READLINE_API extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
 
 /* Clear the history list and start over. */
-extern void clear_history __P((void));
+READLINE_API extern void clear_history __P((void));
 
 /* Stifle the history list, remembering only MAX number of entries. */
-extern void stifle_history __P((int));
+READLINE_API extern void stifle_history __P((int));
 
 /* Stop stifling the history.  This returns the previous amount the
    history was stifled by.  The value is positive if the history was
    stifled, negative if it wasn't. */
-extern int unstifle_history __P((void));
+READLINE_API extern int unstifle_history __P((void));
 
 /* Return 1 if the history is stifled, 0 if it is not. */
-extern int history_is_stifled __P((void));
+READLINE_API extern int history_is_stifled __P((void));
 
 /* Information about the history list. */
 
 /* Return a NULL terminated array of HIST_ENTRY which is the current input
    history.  Element 0 of this list is the beginning of time.  If there
    is no history, return NULL. */
-extern HIST_ENTRY **history_list __P((void));
+READLINE_API extern HIST_ENTRY **history_list __P((void));
 
 /* Returns the number which says what history element we are now
    looking at.  */
-extern int where_history __P((void));
+READLINE_API extern int where_history __P((void));
   
 /* Return the history entry at the current position, as determined by
    history_offset.  If there is no entry there, return a NULL pointer. */
-extern HIST_ENTRY *current_history __P((void));
+READLINE_API extern HIST_ENTRY *current_history __P((void));
 
 /* Return the history entry which is logically at OFFSET in the history
    array.  OFFSET is relative to history_base. */
-extern HIST_ENTRY *history_get __P((int));
+READLINE_API extern HIST_ENTRY *history_get __P((int));
 
 /* Return the number of bytes that the primary history entries are using.
    This just adds up the lengths of the_history->lines. */
-extern int history_total_bytes __P((void));
+READLINE_API extern int history_total_bytes __P((void));
 
 /* Moving around the history list. */
 
 /* Set the position in the history list to POS. */
-extern int history_set_pos __P((int));
+READLINE_API extern int history_set_pos __P((int));
 
 /* Back up history_offset to the previous history entry, and return
    a pointer to that entry.  If there is no previous entry, return
    a NULL pointer. */
-extern HIST_ENTRY *previous_history __P((void));
+READLINE_API extern HIST_ENTRY *previous_history __P((void));
 
 /* Move history_offset forward to the next item in the input_history,
    and return the a pointer to that entry.  If there is no next entry,
    return a NULL pointer. */
-extern HIST_ENTRY *next_history __P((void));
+READLINE_API extern HIST_ENTRY *next_history __P((void));
 
 /* Searching the history list. */
 
@@ -146,45 +154,45 @@
    current_history () is the history entry, and the value of this function
    is the offset in the line of that history entry that the string was
    found in.  Otherwise, nothing is changed, and a -1 is returned. */
-extern int history_search __P((const char *, int));
+READLINE_API extern int history_search __P((const char *, int));
 
 /* Search the history for STRING, starting at history_offset.
    The search is anchored: matching lines must begin with string.
    DIRECTION is as in history_search(). */
-extern int history_search_prefix __P((const char *, int));
+READLINE_API extern int history_search_prefix __P((const char *, int));
 
 /* Search for STRING in the history list, starting at POS, an
    absolute index into the list.  DIR, if negative, says to search
    backwards from POS, else forwards.
    Returns the absolute index of the history element where STRING
    was found, or -1 otherwise. */
-extern int history_search_pos __P((const char *, int, int));
+READLINE_API extern int history_search_pos __P((const char *, int, int));
 
 /* Managing the history file. */
 
 /* Add the contents of FILENAME to the history list, a line at a time.
    If FILENAME is NULL, then read from ~/.history.  Returns 0 if
    successful, or errno if not. */
-extern int read_history __P((const char *));
+READLINE_API extern int read_history __P((const char *));
 
 /* Read a range of lines from FILENAME, adding them to the history list.
    Start reading at the FROM'th line and end at the TO'th.  If FROM
    is zero, start at the beginning.  If TO is less than FROM, read
    until the end of the file.  If FILENAME is NULL, then read from
    ~/.history.  Returns 0 if successful, or errno if not. */
-extern int read_history_range __P((const char *, int, int));
+READLINE_API extern int read_history_range __P((const char *, int, int));
 
 /* Write the current history to FILENAME.  If FILENAME is NULL,
    then write the history list to ~/.history.  Values returned
    are as in read_history ().  */
-extern int write_history __P((const char *));
+READLINE_API extern int write_history __P((const char *));
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
    the end of the list minus NELEMENTs up to the end of the list. */
-extern int append_history __P((int, const char *));
+READLINE_API extern int append_history __P((int, const char *));
 
 /* Truncate the history file, leaving only the last NLINES lines. */
-extern int history_truncate_file __P((const char *, int));
+READLINE_API extern int history_truncate_file __P((const char *, int));
 
 /* History expansion. */
 
@@ -200,12 +208,12 @@
 
   If an error ocurred in expansion, then OUTPUT contains a descriptive
   error message. */
-extern int history_expand __P((char *, char **));
+READLINE_API extern int history_expand __P((char *, char **));
 
 /* Extract a string segment consisting of the FIRST through LAST
    arguments present in STRING.  Arguments are broken up as in
    the shell. */
-extern char *history_arg_extract __P((int, int, const char *));
+READLINE_API extern char *history_arg_extract __P((int, int, const char *));
 
 /* Return the text of the history event beginning at the current
    offset into STRING.  Pass STRING with *INDEX equal to the
@@ -213,31 +221,31 @@
    DELIMITING_QUOTE is a character that is allowed to end the string
    specification for what to search for in addition to the normal
    characters `:', ` ', `\t', `\n', and sometimes `?'. */
-extern char *get_history_event __P((const char *, int *, int));
+READLINE_API extern char *get_history_event __P((const char *, int *, int));
 
 /* Return an array of tokens, much as the shell might.  The tokens are
    parsed out of STRING. */
-extern char **history_tokenize __P((const char *));
+READLINE_API extern char **history_tokenize __P((const char *));
 
 /* Exported history variables. */
-extern int history_base;
-extern int history_length;
-extern int history_max_entries;
-extern char history_expansion_char;
-extern char history_subst_char;
-extern char *history_word_delimiters;
-extern char history_comment_char;
-extern char *history_no_expand_chars;
-extern char *history_search_delimiter_chars;
-extern int history_quotes_inhibit_expansion;
+READLINE_API extern int history_base;
+READLINE_API extern int history_length;
+READLINE_API extern int history_max_entries;
+READLINE_API extern char history_expansion_char;
+READLINE_API extern char history_subst_char;
+READLINE_API extern char *history_word_delimiters;
+READLINE_API extern char history_comment_char;
+READLINE_API extern char *history_no_expand_chars;
+READLINE_API extern char *history_search_delimiter_chars;
+READLINE_API extern int history_quotes_inhibit_expansion;
 
 /* Backwards compatibility */
-extern int max_input_history;
+READLINE_API extern int max_input_history;
 
 /* If set, this function is called to decide whether or not a particular
    history expansion should be treated as a special case for the calling
    application and not expanded. */
-extern rl_linebuf_func_t *history_inhibit_expansion_function;
+READLINE_API extern rl_linebuf_func_t *history_inhibit_expansion_function;
 
 #ifdef __cplusplus
 }
diff -urbBN readline-4.2/input.c readline/input.c
--- readline-4.2/input.c	Tue Mar 27 17:15:04 2001
+++ readline/input.c	Fri Jul 27 18:30:08 2001
@@ -84,6 +84,8 @@
 
 static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
 
+static void rl_gather_tyi ();
+
 /* **************************************************************** */
 /*								    */
 /*			Character Input Buffering       	    */
@@ -149,6 +151,7 @@
   return (0);
 }
 
+#ifndef __MINGW32__
 /* If a character is available to be read, then read it
    and stuff it into IBUFFER.  Otherwise, just return. */
 static void
@@ -269,6 +272,7 @@
 
   return 0;
 }
+#endif /* !__MINGW32__ */
 
 void
 _rl_insert_typein (c)
@@ -381,6 +385,7 @@
   return (c);
 }
 
+#ifndef __MINGW32__
 int
 rl_getc (stream)
      FILE *stream;
@@ -434,3 +439,198 @@
 	return (EOF);
     }
 }
+#else /* __MINGW32__ */
+#include <windows.h>
+#include <ctype.h>
+#include <conio.h>
+#include <io.h>
+
+#define EXT_PREFIX 0x1f8
+
+#define KEV	   irec.Event.KeyEvent			/* to make life easier  */
+#define KST	   irec.Event.KeyEvent.dwControlKeyState
+
+
+static int pending_key = 0;
+static int pending_count = 0;
+static int pending_prefix = 0;
+
+extern int _rl_last_c_pos;	/* imported from display.c  */
+extern int _rl_last_v_pos;
+extern int rl_dispatching;	/* imported from readline.c  */
+extern int rl_point;
+extern int rl_done;
+extern int rl_visible_prompt_length;
+extern int _rl_screenwidth;		/* imported from terminal.c  */
+
+extern int haveConsole;		/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD rlScreenOrigin, rlScreenEnd;
+extern int rlScreenStart, rlScreenMax;
+static void MouseEventProc(MOUSE_EVENT_RECORD kev);
+
+int rl_getc (stream)
+     FILE *stream;
+{
+  int key;
+
+  if ( pending_count )
+    {
+      --pending_count;
+      if ( pending_prefix && (pending_count & 1) )
+        return pending_prefix;
+      else
+        return pending_key;
+    }
+
+  while ( 1 )
+    {
+      DWORD dummy;
+
+      if (WaitForSingleObject(hStdin, WAIT_FOR_INPUT) != WAIT_OBJECT_0)
+        {
+          if ( rl_done )
+            return( 0 );
+          else
+            continue;
+        }
+      if ( haveConsole & FOR_INPUT )
+        {
+          INPUT_RECORD irec;
+          ReadConsoleInput(hStdin, &irec, 1, &dummy);
+          switch(irec.EventType)
+            {
+            case KEY_EVENT:
+              if ( KEV.bKeyDown 
+		   && ((KEV.wVirtualKeyCode < VK_SHIFT) || (KEV.wVirtualKeyCode > VK_MENU)) )
+                {
+                  int mask = 0;
+
+                  key = KEV.uChar.AsciiChar & 0xff;
+                  if ( KST & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) )
+                    mask=0x100;
+                  if ( key )
+                    {
+		      /* Ascii direct */
+                      pending_count = KEV.wRepeatCount - 1;
+                      pending_key = key;
+                      pending_prefix = 0;
+                      if ( mask )
+                        key = tolower(key) | mask;
+                    }
+                  else
+		    /* Others prefixed */
+                    {
+                      key = EXT_PREFIX;
+                      if ( mask )
+                        key |= 4;
+                      if (KST & SHIFT_PRESSED)
+                        key |= 1;
+                      if (KST & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
+                        key |= 2;
+                      mask |= EXT_PREFIX;
+                      pending_count = (KEV.wRepeatCount << 1) - 1;
+                      pending_key = KEV.wVirtualKeyCode;
+                      pending_prefix = key;
+                    }
+                  return key;
+                }
+              break;
+            case MOUSE_EVENT:
+              if ( (haveConsole & FOR_OUTPUT) && !rl_dispatching )
+                MouseEventProc(irec.Event.MouseEvent);
+            default:
+              break;
+            }
+        }
+      else
+        {
+          ReadFile(hStdin, &key, 1, &dummy, NULL);
+          return key;
+        }
+    }
+}
+
+void MouseEventProc(MOUSE_EVENT_RECORD mev)
+{
+  static DWORD lastButtonState, cstat_flags;
+  static COORD lastButtonPos, src_down_pos;
+
+#define RLPOS_CHANGED	1
+#define SELECT_START	2
+  
+  switch (mev.dwEventFlags )
+    {
+    case 0 :			/* change in button state  */
+
+      /* Cursor setting: 
+	 LEFT_BUTTON_PRESSED sets cursor anywhere on the screen,
+	 thereafter, any change in button state will clipp the cursor
+	 position to the readline range if there has been no cursor
+	 movement. Otherwhise the cursor is reset to its old position.
+      */
+      if (mev.dwButtonState == FROM_LEFT_1ST_BUTTON_PRESSED)
+        {
+          if (lastButtonState == 0)
+            {
+              src_down_pos = mev.dwMousePosition;
+              cstat_flags |= RLPOS_CHANGED | SELECT_START;
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+            }
+        }
+      else
+        {
+          if (cstat_flags & RLPOS_CHANGED)
+            {
+              if ( (mev.dwMousePosition.X == src_down_pos.X)
+		   && (mev.dwMousePosition.Y == src_down_pos.Y) )
+                {
+                  int linear_pos = (int)mev.dwMousePosition.Y * _rl_screenwidth
+		    + (int)mev.dwMousePosition.X;
+                  if (linear_pos < rlScreenStart + rl_visible_prompt_length)
+                    {
+                      linear_pos = rlScreenStart + rl_visible_prompt_length;
+                      mev.dwMousePosition.X = rlScreenOrigin.X + rl_visible_prompt_length;
+                      mev.dwMousePosition.Y = rlScreenOrigin.Y;
+                    }
+                  if (linear_pos > rlScreenMax)
+                    {
+                      linear_pos = rlScreenMax;
+                      mev.dwMousePosition = rlScreenEnd;
+                    }
+                  rl_point = linear_pos - rlScreenStart - rl_visible_prompt_length;
+                  _rl_last_c_pos = mev.dwMousePosition.X - rlScreenOrigin.X;
+                  _rl_last_v_pos = mev.dwMousePosition.Y - rlScreenOrigin.Y;
+                }
+              else
+                {
+                  mev.dwMousePosition.X = rlScreenOrigin.X + _rl_last_c_pos;
+                  mev.dwMousePosition.Y = rlScreenOrigin.Y + _rl_last_v_pos;
+                }
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+              cstat_flags &= !RLPOS_CHANGED;
+            }
+        }
+      lastButtonState = mev.dwButtonState;
+      lastButtonPos = mev.dwMousePosition;
+      break;
+    case MOUSE_MOVED:		/* the most frequent event */
+    default:      
+      break;
+    }
+}
+
+int _rl_input_available ()
+{
+  if (isatty (fileno (rl_instream)))
+    return (kbhit());
+  return 0;
+}
+
+static void rl_gather_tyi ()
+{
+  while (isatty (fileno (rl_instream)) && kbhit () && ibuffer_space ())
+    rl_stuff_char ((*rl_getc_function) (rl_instream));
+  return;
+}
+#endif /* __MINGW32__ */
diff -urbBN readline-4.2/inputrc.Win32 readline/inputrc.Win32
--- readline-4.2/inputrc.Win32	Thu Jan  1 01:00:00 1970
+++ readline/inputrc.Win32	Fri Jul 27 17:22:12 2001
@@ -0,0 +1,28 @@
+#
+# This is GNU readline configuration, as built in its Win32 port
+# See readline documentation for more information on how to make
+# new bindings.
+#
+
+set bell-style audible
+set blink-matching-paren on
+
+"\M-\ø%": backward-char
+"\M-\ø'": forward-char
+"\M-\ø$": beginning-of-line
+"\M-\ø#": end-of-line
+"\M-\ø&": previous-history
+"\M-\ø(": next-history
+"\M-\ú%": backward-word
+"\M-\ú'": forward-word
+"\M-\ø.": delete-char
+"": unix-word-rubout
+"\M-\\": "\\"
+"\M-\|": "|"
+"\M-\@": "@"
+"\M-\{": "{"
+"\M-\}": "}"
+"\M-\[": "["
+"\M-\]": "]"
+"\M-\~": "~"
+
diff -urbBN readline-4.2/keymaps.h readline/keymaps.h
--- readline-4.2/keymaps.h	Mon Oct 30 18:23:22 2000
+++ readline/keymaps.h	Fri Jul 27 18:31:38 2001
@@ -23,6 +23,14 @@
 #ifndef _KEYMAPS_H_
 #define _KEYMAPS_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -65,35 +73,35 @@
 #define ISKMAP 1
 #define ISMACR 2
 
-extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
-extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
+READLINE_API extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
+READLINE_API extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
 
 /* Return a new, empty keymap.
    Free it with free() when you are done. */
-extern Keymap rl_make_bare_keymap __P((void));
+READLINE_API extern Keymap rl_make_bare_keymap __P((void));
 
 /* Return a new keymap which is a copy of MAP. */
-extern Keymap rl_copy_keymap __P((Keymap));
+READLINE_API extern Keymap rl_copy_keymap __P((Keymap));
 
 /* Return a new keymap with the printing characters bound to rl_insert,
    the lowercase Meta characters bound to run their equivalents, and
    the Meta digits bound to produce numeric arguments. */
-extern Keymap rl_make_keymap __P((void));
+READLINE_API extern Keymap rl_make_keymap __P((void));
 
 /* Free the storage associated with a keymap. */
-extern void rl_discard_keymap __P((Keymap));
+READLINE_API extern void rl_discard_keymap __P((Keymap));
 
 /* These functions actually appear in bind.c */
 
 /* Return the keymap corresponding to a given name.  Names look like
    `emacs' or `emacs-meta' or `vi-insert'.  */
-extern Keymap rl_get_keymap_by_name __P((const char *));
+READLINE_API extern Keymap rl_get_keymap_by_name __P((const char *));
 
 /* Return the current keymap. */
-extern Keymap rl_get_keymap __P((void));
+READLINE_API extern Keymap rl_get_keymap __P((void));
 
 /* Set the current keymap to MAP. */
-extern void rl_set_keymap __P((Keymap));
+READLINE_API extern void rl_set_keymap __P((Keymap));
 
 #ifdef __cplusplus
 }
diff -urbBN readline-4.2/kill.c readline/kill.c
--- readline-4.2/kill.c	Thu Nov  2 17:36:24 2000
+++ readline/kill.c	Fri Jul 27 18:03:22 2001
@@ -592,7 +592,7 @@
 }
 
 /* A special paste command for users of Cygnus's cygwin32. */
-#if defined (__CYGWIN__)
+#if defined (__CYGWIN__) || defined (__MINGW32__)
 #include <windows.h>
 
 int
diff -urbBN readline-4.2/parens.c readline/parens.c
--- readline-4.2/parens.c	Wed Aug 30 21:10:44 2000
+++ readline/parens.c	Fri Jul 27 17:22:12 2001
@@ -34,6 +34,10 @@
 #  define HAVE_SELECT
 #endif
 
+#ifdef __MINGW32__
+# include <windows.h>
+#endif
+
 #if defined (HAVE_SELECT)
 #  include <sys/time.h>
 #endif /* HAVE_SELECT */
@@ -58,7 +62,7 @@
 
 /* Non-zero means try to blink the matching open parenthesis when the
    close parenthesis is inserted. */
-#if defined (HAVE_SELECT)
+#if defined (HAVE_SELECT) || defined (__MINGW32__)
 int rl_blink_matching_paren = 1;
 #else /* !HAVE_SELECT */
 int rl_blink_matching_paren = 0;
@@ -130,7 +134,24 @@
       (*rl_redisplay_function) ();
       ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
       rl_point = orig_point;
-#else /* !HAVE_SELECT */
+#elif defined (__MINGW32__)
+      int orig_point, match_point, ready;
+
+      rl_insert (1, invoking_key);
+      (*rl_redisplay_function) ();
+      match_point =
+	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);
+
+      /* Emacs might message or ring the bell here, but I don't. */
+      if (match_point < 0)
+	return -1;
+
+      orig_point = rl_point;
+      rl_point = match_point;
+      (*rl_redisplay_function) ();
+      ready = (WaitForSingleObject (GetStdHandle(STD_INPUT_HANDLE), 500) == WAIT_OBJECT_0);
+      rl_point = orig_point;
+#else /* !__MINGW32__ */
       rl_insert (count, invoking_key);
 #endif /* !HAVE_SELECT */
     }
diff -urbBN readline-4.2/posixdir.h readline/posixdir.h
--- readline-4.2/posixdir.h	Thu Aug  5 13:50:18 1999
+++ readline/posixdir.h	Fri Jul 27 17:22:12 2001
@@ -26,6 +26,7 @@
 #if defined (HAVE_DIRENT_H)
 #  include <dirent.h>
 #  define D_NAMLEN(d)   (strlen ((d)->d_name))
+#  define FILENAME(d)   ((d)->d_name)
 #else
 #  if defined (HAVE_SYS_NDIR_H)
 #    include <sys/ndir.h>
@@ -40,7 +41,16 @@
 #    define dirent direct
 #  endif /* !dirent */
 #  define D_NAMLEN(d)   ((d)->d_namlen)
+#  define FILENAME(d)   ((d)->d_name)
 #endif /* !HAVE_DIRENT_H */
+
+#ifdef __MINGW32__
+# undef FILENAME
+# define FILENAME(d) (d).cFileName
+# define closedir(dir) FindClose (dir)
+# undef D_NAMLEN
+# define D_NAMLEN(d) strlen (d.cFileName)
+#endif
 
 #if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
 #  define d_fileno d_ino
diff -urbBN readline-4.2/readline.c readline/readline.c
--- readline-4.2/readline.c	Mon Apr  2 21:56:20 2001
+++ readline/readline.c	Fri Jul 27 17:22:12 2001
@@ -425,7 +425,7 @@
 	}
 
       lastc = c;
-      _rl_dispatch ((unsigned char)c, _rl_keymap);
+      _rl_dispatch (c, _rl_keymap);
 
       /* If there was no change in _rl_last_command_was_kill, then no kill
 	 has taken place.  Note that if input is pending we are reading
@@ -744,8 +744,10 @@
      inputrc file. */
   rl_set_keymap_from_edit_mode ();
 
+#ifndef __MINGW32__
   /* Try to bind a common arrow key prefix, if not already bound. */
   bind_arrow_keys ();
+#endif
 
   /* Enable the meta key, if this terminal has one. */
   if (_rl_enable_meta)
@@ -766,6 +768,7 @@
   rl_tty_set_default_bindings (_rl_keymap);
 }
 
+#ifndef __MINGW32__
 static void
 bind_arrow_keys_internal ()
 {
@@ -821,6 +824,7 @@
 
   _rl_keymap = xkeymap;
 }
+#endif /* !__MINGW32__ */
 
 
 /* **************************************************************** */
@@ -1247,6 +1251,8 @@
     }
   return 0;
 }
+
+extern int _rl_current_display_line ();
 
 /* Clear the current line.  Numeric argument to C-l does this. */
 int
diff -urbBN readline-4.2/readline.dsp readline/readline.dsp
--- readline-4.2/readline.dsp	Thu Jan  1 01:00:00 1970
+++ readline/readline.dsp	Fri Jul 27 20:17:30 2001
@@ -0,0 +1,212 @@
+# Microsoft Developer Studio Project File - Name="readline" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 5.00
+# ** NICHT BEARBEITEN **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=readline - Win32 Debug
+!MESSAGE Dies ist kein gültiges Makefile. Zum Erstellen dieses Projekts mit\
+ NMAKE
+!MESSAGE verwenden Sie den Befehl "Makefile exportieren" und führen Sie den\
+ Befehl
+!MESSAGE 
+!MESSAGE NMAKE /f "readline.mak".
+!MESSAGE 
+!MESSAGE Sie können beim Ausführen von NMAKE eine Konfiguration angeben
+!MESSAGE durch Definieren des Makros CFG in der Befehlszeile. Zum Beispiel:
+!MESSAGE 
+!MESSAGE NMAKE /f "readline.mak" CFG="readline - Win32 Debug"
+!MESSAGE 
+!MESSAGE Für die Konfiguration stehen zur Auswahl:
+!MESSAGE 
+!MESSAGE "readline - Win32 Release" (basierend auf\
+  "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "readline - Win32 Debug" (basierend auf\
+  "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "readline - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Opt"
+# PROP Intermediate_Dir "Opt"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /O2 /Ob2 /I "." /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "__MINGW32__" /D __STDC__=0 /D "HAVE_CONFIG_H" /D "__READLINE_EXPORT__" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+# ADD BASE RSC /l 0x407 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib advapi32.lib /nologo /version:4.2 /subsystem:windows /dll /pdb:none /machine:I386 /out:"Opt/libreadline.dll"
+
+!ELSEIF  "$(CFG)" == "readline - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Dbg"
+# PROP Intermediate_Dir "Dbg"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "." /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "__MINGW32__" /D __STDC__=0 /D "HAVE_CONFIG_H" /D "__READLINE_EXPORT__" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib advapi32.lib /nologo /version:4.2 /subsystem:windows /dll /pdb:none /debug /machine:I386 /out:"Dbg/libreadline.dll"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "readline - Win32 Release"
+# Name "readline - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\bind.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\callback.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\complete.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\display.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\funmap.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\histexpand.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\histfile.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\history.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\histsearch.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\input.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\isearch.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\keymaps.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\kill.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\macro.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\nls.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\parens.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\readline.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\rltty.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\savestring.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\search.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\shell.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\signals.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\terminal.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\tilde.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\undo.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\util.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\vi_mode.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmalloc.c
+# End Source File
+# End Target
+# End Project
diff -urbBN readline-4.2/readline.dsw readline/readline.dsw
--- readline-4.2/readline.dsw	Thu Jan  1 01:00:00 1970
+++ readline/readline.dsw	Fri Jul 27 17:22:14 2001
@@ -0,0 +1,86 @@
+Microsoft Developer Studio Workspace File, Format Version 5.00
+# WARNUNG: DIESE ARBEITSBEREICHSDATEI DARF NICHT BEARBEITET ODER GELÖSCHT WERDEN!
+
+###############################################################################
+
+Project: "fileman"=".\examples\fileman.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name readline
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "readline"=".\readline.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "rltest"=".\examples\rltest.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name readline
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "rlversion"=".\examples\rlversion.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name readline
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "tilde"=".\tilde.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urbBN readline-4.2/readline.h readline/readline.h
--- readline-4.2/readline.h	Wed Feb 14 21:27:54 2001
+++ readline/readline.h	Fri Jul 27 19:52:10 2001
@@ -23,6 +23,14 @@
 #if !defined (_READLINE_H_)
 #define _READLINE_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -56,7 +64,7 @@
 } UNDO_LIST;
 
 /* The current undo list for RL_LINE_BUFFER. */
-extern UNDO_LIST *rl_undo_list;
+READLINE_API extern UNDO_LIST *rl_undo_list;
 
 /* The data structure for mapping textual names to code addresses. */
 typedef struct _funmap {
@@ -64,7 +72,7 @@
   rl_command_func_t *function;
 } FUNMAP;
 
-extern FUNMAP **funmap;
+READLINE_API extern FUNMAP **funmap;
 
 /* **************************************************************** */
 /*								    */
@@ -73,184 +81,184 @@
 /* **************************************************************** */
 
 /* Bindable commands for numeric arguments. */
-extern int rl_digit_argument __P((int, int));
-extern int rl_universal_argument __P((int, int));
+READLINE_API extern int rl_digit_argument __P((int, int));
+READLINE_API extern int rl_universal_argument __P((int, int));
 
 /* Bindable commands for moving the cursor. */
-extern int rl_forward __P((int, int));
-extern int rl_backward __P((int, int));
-extern int rl_beg_of_line __P((int, int));
-extern int rl_end_of_line __P((int, int));
-extern int rl_forward_word __P((int, int));
-extern int rl_backward_word __P((int, int));
-extern int rl_refresh_line __P((int, int));
-extern int rl_clear_screen __P((int, int));
-extern int rl_arrow_keys __P((int, int));
+READLINE_API extern int rl_forward __P((int, int));
+READLINE_API extern int rl_backward __P((int, int));
+READLINE_API extern int rl_beg_of_line __P((int, int));
+READLINE_API extern int rl_end_of_line __P((int, int));
+READLINE_API extern int rl_forward_word __P((int, int));
+READLINE_API extern int rl_backward_word __P((int, int));
+READLINE_API extern int rl_refresh_line __P((int, int));
+READLINE_API extern int rl_clear_screen __P((int, int));
+READLINE_API extern int rl_arrow_keys __P((int, int));
 
 /* Bindable commands for inserting and deleting text. */
-extern int rl_insert __P((int, int));
-extern int rl_quoted_insert __P((int, int));
-extern int rl_tab_insert __P((int, int));
-extern int rl_newline __P((int, int));
-extern int rl_do_lowercase_version __P((int, int));
-extern int rl_rubout __P((int, int));
-extern int rl_delete __P((int, int));
-extern int rl_rubout_or_delete __P((int, int));
-extern int rl_delete_horizontal_space __P((int, int));
-extern int rl_delete_or_show_completions __P((int, int));
-extern int rl_insert_comment __P((int, int));
+READLINE_API extern int rl_insert __P((int, int));
+READLINE_API extern int rl_quoted_insert __P((int, int));
+READLINE_API extern int rl_tab_insert __P((int, int));
+READLINE_API extern int rl_newline __P((int, int));
+READLINE_API extern int rl_do_lowercase_version __P((int, int));
+READLINE_API extern int rl_rubout __P((int, int));
+READLINE_API extern int rl_delete __P((int, int));
+READLINE_API extern int rl_rubout_or_delete __P((int, int));
+READLINE_API extern int rl_delete_horizontal_space __P((int, int));
+READLINE_API extern int rl_delete_or_show_completions __P((int, int));
+READLINE_API extern int rl_insert_comment __P((int, int));
 
 /* Bindable commands for changing case. */
-extern int rl_upcase_word __P((int, int));
-extern int rl_downcase_word __P((int, int));
-extern int rl_capitalize_word __P((int, int));
+READLINE_API extern int rl_upcase_word __P((int, int));
+READLINE_API extern int rl_downcase_word __P((int, int));
+READLINE_API extern int rl_capitalize_word __P((int, int));
 
 /* Bindable commands for transposing characters and words. */
-extern int rl_transpose_words __P((int, int));
-extern int rl_transpose_chars __P((int, int));
+READLINE_API extern int rl_transpose_words __P((int, int));
+READLINE_API extern int rl_transpose_chars __P((int, int));
 
 /* Bindable commands for searching within a line. */
-extern int rl_char_search __P((int, int));
-extern int rl_backward_char_search __P((int, int));
+READLINE_API extern int rl_char_search __P((int, int));
+READLINE_API extern int rl_backward_char_search __P((int, int));
 
 /* Bindable commands for readline's interface to the command history. */
-extern int rl_beginning_of_history __P((int, int));
-extern int rl_end_of_history __P((int, int));
-extern int rl_get_next_history __P((int, int));
-extern int rl_get_previous_history __P((int, int));
+READLINE_API extern int rl_beginning_of_history __P((int, int));
+READLINE_API extern int rl_end_of_history __P((int, int));
+READLINE_API extern int rl_get_next_history __P((int, int));
+READLINE_API extern int rl_get_previous_history __P((int, int));
 
 /* Bindable commands for managing the mark and region. */
-extern int rl_set_mark __P((int, int));
-extern int rl_exchange_point_and_mark __P((int, int));
+READLINE_API extern int rl_set_mark __P((int, int));
+READLINE_API extern int rl_exchange_point_and_mark __P((int, int));
 
 /* Bindable commands to set the editing mode (emacs or vi). */
-extern int rl_vi_editing_mode __P((int, int));
-extern int rl_emacs_editing_mode __P((int, int));
+READLINE_API extern int rl_vi_editing_mode __P((int, int));
+READLINE_API extern int rl_emacs_editing_mode __P((int, int));
 
 /* Bindable commands for managing key bindings. */
-extern int rl_re_read_init_file __P((int, int));
-extern int rl_dump_functions __P((int, int));
-extern int rl_dump_macros __P((int, int));
-extern int rl_dump_variables __P((int, int));
+READLINE_API extern int rl_re_read_init_file __P((int, int));
+READLINE_API extern int rl_dump_functions __P((int, int));
+READLINE_API extern int rl_dump_macros __P((int, int));
+READLINE_API extern int rl_dump_variables __P((int, int));
 
 /* Bindable commands for word completion. */
-extern int rl_complete __P((int, int));
-extern int rl_possible_completions __P((int, int));
-extern int rl_insert_completions __P((int, int));
-extern int rl_menu_complete __P((int, int));
+READLINE_API extern int rl_complete __P((int, int));
+READLINE_API extern int rl_possible_completions __P((int, int));
+READLINE_API extern int rl_insert_completions __P((int, int));
+READLINE_API extern int rl_menu_complete __P((int, int));
 
 /* Bindable commands for killing and yanking text, and managing the kill ring. */
-extern int rl_kill_word __P((int, int));
-extern int rl_backward_kill_word __P((int, int));
-extern int rl_kill_line __P((int, int));
-extern int rl_backward_kill_line __P((int, int));
-extern int rl_kill_full_line __P((int, int));
-extern int rl_unix_word_rubout __P((int, int));
-extern int rl_unix_line_discard __P((int, int));
-extern int rl_copy_region_to_kill __P((int, int));
-extern int rl_kill_region __P((int, int));
-extern int rl_copy_forward_word __P((int, int));
-extern int rl_copy_backward_word __P((int, int));
-extern int rl_yank __P((int, int));
-extern int rl_yank_pop __P((int, int));
-extern int rl_yank_nth_arg __P((int, int));
-extern int rl_yank_last_arg __P((int, int));
+READLINE_API extern int rl_kill_word __P((int, int));
+READLINE_API extern int rl_backward_kill_word __P((int, int));
+READLINE_API extern int rl_kill_line __P((int, int));
+READLINE_API extern int rl_backward_kill_line __P((int, int));
+READLINE_API extern int rl_kill_full_line __P((int, int));
+READLINE_API extern int rl_unix_word_rubout __P((int, int));
+READLINE_API extern int rl_unix_line_discard __P((int, int));
+READLINE_API extern int rl_copy_region_to_kill __P((int, int));
+READLINE_API extern int rl_kill_region __P((int, int));
+READLINE_API extern int rl_copy_forward_word __P((int, int));
+READLINE_API extern int rl_copy_backward_word __P((int, int));
+READLINE_API extern int rl_yank __P((int, int));
+READLINE_API extern int rl_yank_pop __P((int, int));
+READLINE_API extern int rl_yank_nth_arg __P((int, int));
+READLINE_API extern int rl_yank_last_arg __P((int, int));
 /* Not available unless __CYGWIN__ is defined. */
-#ifdef __CYGWIN__
-extern int rl_paste_from_clipboard __P((int, int));
+#if defined(__CYGWIN__) || defined (__MINGW32__)
+READLINE_API extern int rl_paste_from_clipboard __P((int, int));
 #endif
 
 /* Bindable commands for incremental searching. */
-extern int rl_reverse_search_history __P((int, int));
-extern int rl_forward_search_history __P((int, int));
+READLINE_API extern int rl_reverse_search_history __P((int, int));
+READLINE_API extern int rl_forward_search_history __P((int, int));
 
 /* Bindable keyboard macro commands. */
-extern int rl_start_kbd_macro __P((int, int));
-extern int rl_end_kbd_macro __P((int, int));
-extern int rl_call_last_kbd_macro __P((int, int));
+READLINE_API extern int rl_start_kbd_macro __P((int, int));
+READLINE_API extern int rl_end_kbd_macro __P((int, int));
+READLINE_API extern int rl_call_last_kbd_macro __P((int, int));
 
 /* Bindable undo commands. */
-extern int rl_revert_line __P((int, int));
-extern int rl_undo_command __P((int, int));
+READLINE_API extern int rl_revert_line __P((int, int));
+READLINE_API extern int rl_undo_command __P((int, int));
 
 /* Bindable tilde expansion commands. */
-extern int rl_tilde_expand __P((int, int));
+READLINE_API extern int rl_tilde_expand __P((int, int));
 
 /* Bindable terminal control commands. */
-extern int rl_restart_output __P((int, int));
-extern int rl_stop_output __P((int, int));
+READLINE_API extern int rl_restart_output __P((int, int));
+READLINE_API extern int rl_stop_output __P((int, int));
 
 /* Miscellaneous bindable commands. */
-extern int rl_abort __P((int, int));
-extern int rl_tty_status __P((int, int));
+READLINE_API extern int rl_abort __P((int, int));
+READLINE_API extern int rl_tty_status __P((int, int));
 
 /* Bindable commands for incremental and non-incremental history searching. */
-extern int rl_history_search_forward __P((int, int));
-extern int rl_history_search_backward __P((int, int));
-extern int rl_noninc_forward_search __P((int, int));
-extern int rl_noninc_reverse_search __P((int, int));
-extern int rl_noninc_forward_search_again __P((int, int));
-extern int rl_noninc_reverse_search_again __P((int, int));
+READLINE_API extern int rl_history_search_forward __P((int, int));
+READLINE_API extern int rl_history_search_backward __P((int, int));
+READLINE_API extern int rl_noninc_forward_search __P((int, int));
+READLINE_API extern int rl_noninc_reverse_search __P((int, int));
+READLINE_API extern int rl_noninc_forward_search_again __P((int, int));
+READLINE_API extern int rl_noninc_reverse_search_again __P((int, int));
 
 /* Bindable command used when inserting a matching close character. */
-extern int rl_insert_close __P((int, int));
+READLINE_API extern int rl_insert_close __P((int, int));
 
 /* Not available unless READLINE_CALLBACKS is defined. */
-extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
-extern void rl_callback_read_char __P((void));
-extern void rl_callback_handler_remove __P((void));
+READLINE_API extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
+READLINE_API extern void rl_callback_read_char __P((void));
+READLINE_API extern void rl_callback_handler_remove __P((void));
 
 /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
 /* VI-mode bindable commands. */
-extern int rl_vi_redo __P((int, int));
-extern int rl_vi_undo __P((int, int));
-extern int rl_vi_yank_arg __P((int, int));
-extern int rl_vi_fetch_history __P((int, int));
-extern int rl_vi_search_again __P((int, int));
-extern int rl_vi_search __P((int, int));
-extern int rl_vi_complete __P((int, int));
-extern int rl_vi_tilde_expand __P((int, int));
-extern int rl_vi_prev_word __P((int, int));
-extern int rl_vi_next_word __P((int, int));
-extern int rl_vi_end_word __P((int, int));
-extern int rl_vi_insert_beg __P((int, int));
-extern int rl_vi_append_mode __P((int, int));
-extern int rl_vi_append_eol __P((int, int));
-extern int rl_vi_eof_maybe __P((int, int));
-extern int rl_vi_insertion_mode __P((int, int));
-extern int rl_vi_movement_mode __P((int, int));
-extern int rl_vi_arg_digit __P((int, int));
-extern int rl_vi_change_case __P((int, int));
-extern int rl_vi_put __P((int, int));
-extern int rl_vi_column __P((int, int));
-extern int rl_vi_delete_to __P((int, int));
-extern int rl_vi_change_to __P((int, int));
-extern int rl_vi_yank_to __P((int, int));
-extern int rl_vi_delete __P((int, int));
-extern int rl_vi_back_to_indent __P((int, int));
-extern int rl_vi_first_print __P((int, int));
-extern int rl_vi_char_search __P((int, int));
-extern int rl_vi_match __P((int, int));
-extern int rl_vi_change_char __P((int, int));
-extern int rl_vi_subst __P((int, int));
-extern int rl_vi_overstrike __P((int, int));
-extern int rl_vi_overstrike_delete __P((int, int));
-extern int rl_vi_replace __P((int, int));
-extern int rl_vi_set_mark __P((int, int));
-extern int rl_vi_goto_mark __P((int, int));
+READLINE_API extern int rl_vi_redo __P((int, int));
+READLINE_API extern int rl_vi_undo __P((int, int));
+READLINE_API extern int rl_vi_yank_arg __P((int, int));
+READLINE_API extern int rl_vi_fetch_history __P((int, int));
+READLINE_API extern int rl_vi_search_again __P((int, int));
+READLINE_API extern int rl_vi_search __P((int, int));
+READLINE_API extern int rl_vi_complete __P((int, int));
+READLINE_API extern int rl_vi_tilde_expand __P((int, int));
+READLINE_API extern int rl_vi_prev_word __P((int, int));
+READLINE_API extern int rl_vi_next_word __P((int, int));
+READLINE_API extern int rl_vi_end_word __P((int, int));
+READLINE_API extern int rl_vi_insert_beg __P((int, int));
+READLINE_API extern int rl_vi_append_mode __P((int, int));
+READLINE_API extern int rl_vi_append_eol __P((int, int));
+READLINE_API extern int rl_vi_eof_maybe __P((int, int));
+READLINE_API extern int rl_vi_insertion_mode __P((int, int));
+READLINE_API extern int rl_vi_movement_mode __P((int, int));
+READLINE_API extern int rl_vi_arg_digit __P((int, int));
+READLINE_API extern int rl_vi_change_case __P((int, int));
+READLINE_API extern int rl_vi_put __P((int, int));
+READLINE_API extern int rl_vi_column __P((int, int));
+READLINE_API extern int rl_vi_delete_to __P((int, int));
+READLINE_API extern int rl_vi_change_to __P((int, int));
+READLINE_API extern int rl_vi_yank_to __P((int, int));
+READLINE_API extern int rl_vi_delete __P((int, int));
+READLINE_API extern int rl_vi_back_to_indent __P((int, int));
+READLINE_API extern int rl_vi_first_print __P((int, int));
+READLINE_API extern int rl_vi_char_search __P((int, int));
+READLINE_API extern int rl_vi_match __P((int, int));
+READLINE_API extern int rl_vi_change_char __P((int, int));
+READLINE_API extern int rl_vi_subst __P((int, int));
+READLINE_API extern int rl_vi_overstrike __P((int, int));
+READLINE_API extern int rl_vi_overstrike_delete __P((int, int));
+READLINE_API extern int rl_vi_replace __P((int, int));
+READLINE_API extern int rl_vi_set_mark __P((int, int));
+READLINE_API extern int rl_vi_goto_mark __P((int, int));
 
 /* VI-mode utility functions. */
-extern int rl_vi_check __P((void));
-extern int rl_vi_domove __P((int, int *));
-extern int rl_vi_bracktype __P((int));
+READLINE_API extern int rl_vi_check __P((void));
+READLINE_API extern int rl_vi_domove __P((int, int *));
+READLINE_API extern int rl_vi_bracktype __P((int));
 
 /* VI-mode pseudo-bindable commands, used as utility functions. */
-extern int rl_vi_fWord __P((int, int));
-extern int rl_vi_bWord __P((int, int));
-extern int rl_vi_eWord __P((int, int));
-extern int rl_vi_fword __P((int, int));
-extern int rl_vi_bword __P((int, int));
-extern int rl_vi_eword __P((int, int));
+READLINE_API extern int rl_vi_fWord __P((int, int));
+READLINE_API extern int rl_vi_bWord __P((int, int));
+READLINE_API extern int rl_vi_eWord __P((int, int));
+READLINE_API extern int rl_vi_fword __P((int, int));
+READLINE_API extern int rl_vi_bword __P((int, int));
+READLINE_API extern int rl_vi_eword __P((int, int));
 
 /* **************************************************************** */
 /*								    */
@@ -260,171 +268,171 @@
 
 /* Readline functions. */
 /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
-extern char *readline __P((const char *));
+READLINE_API extern char *readline __P((const char *));
 
-extern int rl_set_prompt __P((const char *));
-extern int rl_expand_prompt __P((char *));
+READLINE_API extern int rl_set_prompt __P((const char *));
+READLINE_API extern int rl_expand_prompt __P((char *));
 
-extern int rl_initialize __P((void));
+READLINE_API extern int rl_initialize __P((void));
 
 /* Undocumented; unused by readline */
-extern int rl_discard_argument __P((void));
+READLINE_API extern int rl_discard_argument __P((void));
 
 /* Utility functions to bind keys to readline commands. */
-extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
-extern int rl_bind_key __P((int, rl_command_func_t *));
-extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
-extern int rl_unbind_key __P((int));
-extern int rl_unbind_key_in_map __P((int, Keymap));
-extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
-extern int rl_unbind_command_in_map __P((const char *, Keymap));
-extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
-extern int rl_generic_bind __P((int, const char *, char *, Keymap));
-extern int rl_variable_bind __P((const char *, const char *));
+READLINE_API extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
+READLINE_API extern int rl_bind_key __P((int, rl_command_func_t *));
+READLINE_API extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
+READLINE_API extern int rl_unbind_key __P((int));
+READLINE_API extern int rl_unbind_key_in_map __P((int, Keymap));
+READLINE_API extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
+READLINE_API extern int rl_unbind_command_in_map __P((const char *, Keymap));
+READLINE_API extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
+READLINE_API extern int rl_generic_bind __P((int, const char *, char *, Keymap));
+READLINE_API extern int rl_variable_bind __P((const char *, const char *));
 
 /* Backwards compatibility, use rl_generic_bind instead. */
-extern int rl_macro_bind __P((const char *, const char *, Keymap));
+READLINE_API extern int rl_macro_bind __P((const char *, const char *, Keymap));
 
 /* Undocumented in the texinfo manual; not really useful to programs. */
-extern int rl_translate_keyseq __P((const char *, char *, int *));
-extern char *rl_untranslate_keyseq __P((int));
+READLINE_API extern int rl_translate_keyseq __P((const char *, char *, int *));
+READLINE_API extern char *rl_untranslate_keyseq __P((int));
 
-extern rl_command_func_t *rl_named_function __P((const char *));
-extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
+READLINE_API extern rl_command_func_t *rl_named_function __P((const char *));
+READLINE_API extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
 
-extern void rl_list_funmap_names __P((void));
-extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
-extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
- 
-extern void rl_function_dumper __P((int));
-extern void rl_macro_dumper __P((int));
-extern void rl_variable_dumper __P((int));
+READLINE_API extern void rl_list_funmap_names __P((void));
+READLINE_API extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
+READLINE_API extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
+ 
+READLINE_API extern void rl_function_dumper __P((int));
+READLINE_API extern void rl_macro_dumper __P((int));
+READLINE_API extern void rl_variable_dumper __P((int));
 
-extern int rl_read_init_file __P((const char *));
-extern int rl_parse_and_bind __P((char *));
+READLINE_API extern int rl_read_init_file __P((const char *));
+READLINE_API extern int rl_parse_and_bind __P((char *));
 
 /* Functions for manipulating keymaps. */
-extern Keymap rl_make_bare_keymap __P((void));
-extern Keymap rl_copy_keymap __P((Keymap));
-extern Keymap rl_make_keymap __P((void));
-extern void rl_discard_keymap __P((Keymap));
-
-extern Keymap rl_get_keymap_by_name __P((const char *));
-extern char *rl_get_keymap_name __P((Keymap));
-extern void rl_set_keymap __P((Keymap));
-extern Keymap rl_get_keymap __P((void));
+READLINE_API extern Keymap rl_make_bare_keymap __P((void));
+READLINE_API extern Keymap rl_copy_keymap __P((Keymap));
+READLINE_API extern Keymap rl_make_keymap __P((void));
+READLINE_API extern void rl_discard_keymap __P((Keymap));
+
+READLINE_API extern Keymap rl_get_keymap_by_name __P((const char *));
+READLINE_API extern char *rl_get_keymap_name __P((Keymap));
+READLINE_API extern void rl_set_keymap __P((Keymap));
+READLINE_API extern Keymap rl_get_keymap __P((void));
 /* Undocumented; used internally only. */
-extern void rl_set_keymap_from_edit_mode __P((void));
-extern char *rl_get_keymap_name_from_edit_mode __P((void));
+READLINE_API extern void rl_set_keymap_from_edit_mode __P((void));
+READLINE_API extern char *rl_get_keymap_name_from_edit_mode __P((void));
 
 /* Functions for manipulating the funmap, which maps command names to functions. */
-extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
-extern const char **rl_funmap_names __P((void));
+READLINE_API extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
+READLINE_API extern const char **rl_funmap_names __P((void));
 /* Undocumented, only used internally -- there is only one funmap, and this
    function may be called only once. */
-extern void rl_initialize_funmap __P((void));
+READLINE_API extern void rl_initialize_funmap __P((void));
 
 /* Utility functions for managing keyboard macros. */
-extern void rl_push_macro_input __P((char *));
+READLINE_API extern void rl_push_macro_input __P((char *));
 
 /* Functions for undoing, from undo.c */
-extern void rl_add_undo __P((enum undo_code, int, int, char *));
-extern void rl_free_undo_list __P((void));
-extern int rl_do_undo __P((void));
-extern int rl_begin_undo_group __P((void));
-extern int rl_end_undo_group __P((void));
-extern int rl_modifying __P((int, int));
+READLINE_API extern void rl_add_undo __P((enum undo_code, int, int, char *));
+READLINE_API extern void rl_free_undo_list __P((void));
+READLINE_API extern int rl_do_undo __P((void));
+READLINE_API extern int rl_begin_undo_group __P((void));
+READLINE_API extern int rl_end_undo_group __P((void));
+READLINE_API extern int rl_modifying __P((int, int));
 
 /* Functions for redisplay. */
-extern void rl_redisplay __P((void));
-extern int rl_on_new_line __P((void));
-extern int rl_on_new_line_with_prompt __P((void));
-extern int rl_forced_update_display __P((void));
-extern int rl_clear_message __P((void));
-extern int rl_reset_line_state __P((void));
-extern int rl_crlf __P((void));
+READLINE_API extern void rl_redisplay __P((void));
+READLINE_API extern int rl_on_new_line __P((void));
+READLINE_API extern int rl_on_new_line_with_prompt __P((void));
+READLINE_API extern int rl_forced_update_display __P((void));
+READLINE_API extern int rl_clear_message __P((void));
+READLINE_API extern int rl_reset_line_state __P((void));
+READLINE_API extern int rl_crlf __P((void));
 
 #if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
-extern int rl_message (const char *, ...);
+READLINE_API extern int rl_message (const char *, ...);
 #else
-extern int rl_message ();
+READLINE_API extern int rl_message ();
 #endif
 
-extern int rl_show_char __P((int));
+READLINE_API extern int rl_show_char __P((int));
 
 /* Undocumented in texinfo manual. */
-extern int rl_character_len __P((int, int));
+READLINE_API extern int rl_character_len __P((int, int));
 
 /* Save and restore internal prompt redisplay information. */
-extern void rl_save_prompt __P((void));
-extern void rl_restore_prompt __P((void));
+READLINE_API extern void rl_save_prompt __P((void));
+READLINE_API extern void rl_restore_prompt __P((void));
 
 /* Modifying text. */
-extern int rl_insert_text __P((const char *));
-extern int rl_delete_text __P((int, int));
-extern int rl_kill_text __P((int, int));
-extern char *rl_copy_text __P((int, int));
+READLINE_API extern int rl_insert_text __P((const char *));
+READLINE_API extern int rl_delete_text __P((int, int));
+READLINE_API extern int rl_kill_text __P((int, int));
+READLINE_API extern char *rl_copy_text __P((int, int));
 
 /* Terminal and tty mode management. */
-extern void rl_prep_terminal __P((int));
-extern void rl_deprep_terminal __P((void));
-extern void rl_tty_set_default_bindings __P((Keymap));
-
-extern int rl_reset_terminal __P((const char *));
-extern void rl_resize_terminal __P((void));
-extern void rl_set_screen_size __P((int, int));
-extern void rl_get_screen_size __P((int *, int *));
+READLINE_API extern void rl_prep_terminal __P((int));
+READLINE_API extern void rl_deprep_terminal __P((void));
+READLINE_API extern void rl_tty_set_default_bindings __P((Keymap));
+
+READLINE_API extern int rl_reset_terminal __P((const char *));
+READLINE_API extern void rl_resize_terminal __P((void));
+READLINE_API extern void rl_set_screen_size __P((int, int));
+READLINE_API extern void rl_get_screen_size __P((int *, int *));
 
 /* Functions for character input. */
-extern int rl_stuff_char __P((int));
-extern int rl_execute_next __P((int));
-extern int rl_clear_pending_input __P((void));
-extern int rl_read_key __P((void));
-extern int rl_getc __P((FILE *));
-extern int rl_set_keyboard_input_timeout __P((int));
+READLINE_API extern int rl_stuff_char __P((int));
+READLINE_API extern int rl_execute_next __P((int));
+READLINE_API extern int rl_clear_pending_input __P((void));
+READLINE_API extern int rl_read_key __P((void));
+READLINE_API extern int rl_getc __P((FILE *));
+READLINE_API extern int rl_set_keyboard_input_timeout __P((int));
 
 /* `Public' utility functions . */
-extern void rl_extend_line_buffer __P((int));
-extern int rl_ding __P((void));
-extern int rl_alphabetic __P((int));
+READLINE_API extern void rl_extend_line_buffer __P((int));
+READLINE_API extern int rl_ding __P((void));
+READLINE_API extern int rl_alphabetic __P((int));
 
 /* Readline signal handling, from signals.c */
-extern int rl_set_signals __P((void));
-extern int rl_clear_signals __P((void));
-extern void rl_cleanup_after_signal __P((void));
-extern void rl_reset_after_signal __P((void));
-extern void rl_free_line_state __P((void));
+READLINE_API extern int rl_set_signals __P((void));
+READLINE_API extern int rl_clear_signals __P((void));
+READLINE_API extern void rl_cleanup_after_signal __P((void));
+READLINE_API extern void rl_reset_after_signal __P((void));
+READLINE_API extern void rl_free_line_state __P((void));
  
 /* Undocumented. */
-extern int rl_set_paren_blink_timeout __P((int));
+READLINE_API extern int rl_set_paren_blink_timeout __P((int));
 
 /* Undocumented. */
-extern int rl_maybe_save_line __P((void));
-extern int rl_maybe_unsave_line __P((void));
-extern int rl_maybe_replace_line __P((void));
+READLINE_API extern int rl_maybe_save_line __P((void));
+READLINE_API extern int rl_maybe_unsave_line __P((void));
+READLINE_API extern int rl_maybe_replace_line __P((void));
 
 /* Completion functions. */
-extern int rl_complete_internal __P((int));
-extern void rl_display_match_list __P((char **, int, int));
+READLINE_API extern int rl_complete_internal __P((int));
+READLINE_API extern void rl_display_match_list __P((char **, int, int));
 
-extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
-extern char *rl_username_completion_function __P((const char *, int));
-extern char *rl_filename_completion_function __P((const char *, int));
+READLINE_API extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
+READLINE_API extern char *rl_username_completion_function __P((const char *, int));
+READLINE_API extern char *rl_filename_completion_function __P((const char *, int));
 
-#if 0
+#if 1
 /* Backwards compatibility (compat.c).  These will go away sometime. */
-extern void free_undo_list __P((void));
-extern int maybe_save_line __P((void));
-extern int maybe_unsave_line __P((void));
-extern int maybe_replace_line __P((void));
-
-extern int ding __P((void));
-extern int alphabetic __P((int));
-extern int crlf __P((void));
-
-extern char **completion_matches __P((char *, rl_compentry_func_t *));
-extern char *username_completion_function __P((const char *, int));
-extern char *filename_completion_function __P((const char *, int));
+READLINE_API extern void free_undo_list __P((void));
+READLINE_API extern int maybe_save_line __P((void));
+READLINE_API extern int maybe_unsave_line __P((void));
+READLINE_API extern int maybe_replace_line __P((void));
+
+READLINE_API extern int ding __P((void));
+READLINE_API extern int alphabetic __P((int));
+READLINE_API extern int crlf __P((void));
+
+READLINE_API extern char **completion_matches __P((const char *, rl_compentry_func_t *));
+READLINE_API extern char *username_completion_function __P((const char *, int));
+READLINE_API extern char *filename_completion_function __P((const char *, int));
 #endif
 
 /* **************************************************************** */
@@ -434,126 +442,126 @@
 /* **************************************************************** */
 
 /* The version of this incarnation of the readline library. */
-extern const char *rl_library_version;
+READLINE_API extern const char *rl_library_version;
 
 /* True if this is real GNU readline. */
-extern int rl_gnu_readline_p;
+READLINE_API extern int rl_gnu_readline_p;
 
 /* Flags word encapsulating the current readline state. */
-extern int rl_readline_state;
+READLINE_API extern int rl_readline_state;
 
 /* Says which editing mode readline is currently using.  1 means emacs mode;
    0 means vi mode. */
-extern int rl_editing_mode;
+READLINE_API extern int rl_editing_mode;
 
 /* The name of the calling program.  You should initialize this to
    whatever was in argv[0].  It is used when parsing conditionals. */
-extern const char *rl_readline_name;
+READLINE_API extern const char *rl_readline_name;
 
 /* The prompt readline uses.  This is set from the argument to
    readline (), and should not be assigned to directly. */
-extern char *rl_prompt;
+READLINE_API extern char *rl_prompt;
 
 /* The line buffer that is in use. */
-extern char *rl_line_buffer;
+READLINE_API extern char *rl_line_buffer;
 
 /* The location of point, and end. */
-extern int rl_point;
-extern int rl_end;
+READLINE_API extern int rl_point;
+READLINE_API extern int rl_end;
 
 /* The mark, or saved cursor position. */
-extern int rl_mark;
+READLINE_API extern int rl_mark;
 
 /* Flag to indicate that readline has finished with the current input
    line and should return it. */
-extern int rl_done;
+READLINE_API extern int rl_done;
 
 /* If set to a character value, that will be the next keystroke read. */
-extern int rl_pending_input;
+READLINE_API extern int rl_pending_input;
 
 /* Non-zero if we called this function from _rl_dispatch().  It's present
    so functions can find out whether they were called from a key binding
    or directly from an application. */
-extern int rl_dispatching;
+READLINE_API extern int rl_dispatching;
 
 /* Non-zero if the user typed a numeric argument before executing the
    current function. */
-extern int rl_explicit_arg;
+READLINE_API extern int rl_explicit_arg;
 
 /* The current value of the numeric argument specified by the user. */
-extern int rl_numeric_arg;
+READLINE_API extern int rl_numeric_arg;
 
 /* The address of the last command function Readline executed. */
-extern rl_command_func_t *rl_last_func;
+READLINE_API extern rl_command_func_t *rl_last_func;
 
 /* The name of the terminal to use. */
-extern const char *rl_terminal_name;
+READLINE_API extern const char *rl_terminal_name;
 
 /* The input and output streams. */
-extern FILE *rl_instream;
-extern FILE *rl_outstream;
+READLINE_API extern FILE *rl_instream;
+READLINE_API extern FILE *rl_outstream;
 
 /* If non-zero, then this is the address of a function to call just
    before readline_internal () prints the first prompt. */
-extern rl_hook_func_t *rl_startup_hook;
+READLINE_API extern rl_hook_func_t *rl_startup_hook;
 
 /* If non-zero, this is the address of a function to call just before
    readline_internal_setup () returns and readline_internal starts
    reading input characters. */
-extern rl_hook_func_t *rl_pre_input_hook;
+READLINE_API extern rl_hook_func_t *rl_pre_input_hook;
       
 /* The address of a function to call periodically while Readline is
    awaiting character input, or NULL, for no event handling. */
-extern rl_hook_func_t *rl_event_hook;
+READLINE_API extern rl_hook_func_t *rl_event_hook;
 
 /* The address of the function to call to fetch a character from the current
    Readline input stream */
-extern rl_getc_func_t *rl_getc_function;
+READLINE_API extern rl_getc_func_t *rl_getc_function;
 
-extern rl_voidfunc_t *rl_redisplay_function;
+READLINE_API extern rl_voidfunc_t *rl_redisplay_function;
 
-extern rl_vintfunc_t *rl_prep_term_function;
-extern rl_voidfunc_t *rl_deprep_term_function;
+READLINE_API extern rl_vintfunc_t *rl_prep_term_function;
+READLINE_API extern rl_voidfunc_t *rl_deprep_term_function;
 
 /* Dispatch variables. */
-extern Keymap rl_executing_keymap;
-extern Keymap rl_binding_keymap;
+READLINE_API extern Keymap rl_executing_keymap;
+READLINE_API extern Keymap rl_binding_keymap;
 
 /* Display variables. */
 /* If non-zero, readline will erase the entire line, including any prompt,
    if the only thing typed on an otherwise-blank line is something bound to
    rl_newline. */
-extern int rl_erase_empty_line;
+READLINE_API extern int rl_erase_empty_line;
 
 /* If non-zero, the application has already printed the prompt (rl_prompt)
    before calling readline, so readline should not output it the first time
    redisplay is done. */
-extern int rl_already_prompted;
+READLINE_API extern int rl_already_prompted;
 
 /* A non-zero value means to read only this many characters rather than
    up to a character bound to accept-line. */
-extern int rl_num_chars_to_read;
+READLINE_API extern int rl_num_chars_to_read;
 
 /* The text of a currently-executing keyboard macro. */
-extern char *rl_executing_macro;
+READLINE_API extern char *rl_executing_macro;
 
 /* Variables to control readline signal handling. */
 /* If non-zero, readline will install its own signal handlers for
    SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
-extern int rl_catch_signals;
+READLINE_API extern int rl_catch_signals;
 
 /* If non-zero, readline will install a signal handler for SIGWINCH
    that also attempts to call any calling application's SIGWINCH signal
    handler.  Note that the terminal is not cleaned up before the
    application's signal handler is called; use rl_cleanup_after_signal()
    to do that. */
-extern int rl_catch_sigwinch;
+READLINE_API extern int rl_catch_sigwinch;
 
 /* Completion variables. */
 /* Pointer to the generator function for completion_matches ().
    NULL means to use filename_entry_function (), the default filename
    completer. */
-extern rl_compentry_func_t *rl_completion_entry_function;
+READLINE_API extern rl_compentry_func_t *rl_completion_entry_function;
 
 /* If rl_ignore_some_completions_function is non-NULL it is the address
    of a function to call after all of the possible matches have been
@@ -561,7 +569,7 @@
    The function is called with one argument; a NULL terminated array
    of (char *).  If your function removes any of the elements, they
    must be free()'ed. */
-extern rl_compignore_func_t *rl_ignore_some_completions_function;
+READLINE_API extern rl_compignore_func_t *rl_ignore_some_completions_function;
 
 /* Pointer to alternative function to create matches.
    Function is called with TEXT, START, and END.
@@ -570,41 +578,41 @@
    If this function exists and returns NULL then call the value of
    rl_completion_entry_function to try to match, otherwise use the
    array of strings returned. */
-extern rl_completion_func_t *rl_attempted_completion_function;
+READLINE_API extern rl_completion_func_t *rl_attempted_completion_function;
 
 /* The basic list of characters that signal a break between words for the
    completer routine.  The initial contents of this variable is what
    breaks words in the shell, i.e. "n\"\\'`@$>". */
-extern const char *rl_basic_word_break_characters;
+READLINE_API extern const char *rl_basic_word_break_characters;
 
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-extern const char *rl_completer_word_break_characters;
+READLINE_API extern const char *rl_completer_word_break_characters;
 
 /* List of characters which can be used to quote a substring of the line.
    Completion occurs on the entire substring, and within the substring   
    rl_completer_word_break_characters are treated as any other character,
    unless they also appear within this list. */
-extern const char *rl_completer_quote_characters;
+READLINE_API extern const char *rl_completer_quote_characters;
 
 /* List of quote characters which cause a word break. */
-extern const char *rl_basic_quote_characters;
+READLINE_API extern const char *rl_basic_quote_characters;
 
 /* List of characters that need to be quoted in filenames by the completer. */
-extern const char *rl_filename_quote_characters;
+READLINE_API extern const char *rl_filename_quote_characters;
 
 /* List of characters that are word break characters, but should be left
    in TEXT when it is passed to the completion function.  The shell uses
    this to help determine what kind of completing to do. */
-extern const char *rl_special_prefixes;
+READLINE_API extern const char *rl_special_prefixes;
 
 /* If non-zero, then this is the address of a function to call when
    completing on a directory name.  The function is called with
    the address of a string (the current directory name) as an arg.  It
    changes what is displayed when the possible completions are printed
    or inserted. */
-extern rl_icppfunc_t *rl_directory_completion_hook;
+READLINE_API extern rl_icppfunc_t *rl_directory_completion_hook;
 
 /* If non-zero, this is the address of a function to call when completing
    a directory name.  This function takes the address of the directory name
@@ -613,7 +621,7 @@
    when the possible completions are printed or inserted.  It is called
    before rl_directory_completion_hook.  I'm not happy with how this works
    yet, so it's undocumented. */
-extern rl_icppfunc_t *rl_directory_rewrite_hook;
+READLINE_API extern rl_icppfunc_t *rl_directory_rewrite_hook;
 
 /* Backwards compatibility with previous versions of readline. */
 #define rl_symbolic_link_hook rl_directory_completion_hook
@@ -625,60 +633,60 @@
    where MATCHES is the array of strings that matched, NUM_MATCHES is the
    number of strings in that array, and MAX_LENGTH is the length of the
    longest string in that array. */
-extern rl_compdisp_func_t *rl_completion_display_matches_hook;
+READLINE_API extern rl_compdisp_func_t *rl_completion_display_matches_hook;
 
 /* Non-zero means that the results of the matches are to be treated
    as filenames.  This is ALWAYS zero on entry, and can only be changed
    within a completion entry finder function. */
-extern int rl_filename_completion_desired;
+READLINE_API extern int rl_filename_completion_desired;
 
 /* Non-zero means that the results of the matches are to be quoted using
    double quotes (or an application-specific quoting mechanism) if the
    filename contains any characters in rl_word_break_chars.  This is
    ALWAYS non-zero on entry, and can only be changed within a completion
    entry finder function. */
-extern int rl_filename_quoting_desired;
+READLINE_API extern int rl_filename_quoting_desired;
 
 /* Set to a function to quote a filename in an application-specific fashion.
    Called with the text to quote, the type of match found (single or multiple)
    and a pointer to the quoting character to be used, which the function can
    reset if desired. */
-extern rl_quote_func_t *rl_filename_quoting_function;
+READLINE_API extern rl_quote_func_t *rl_filename_quoting_function;
 
 /* Function to call to remove quoting characters from a filename.  Called
    before completion is attempted, so the embedded quotes do not interfere
    with matching names in the file system. */
-extern rl_dequote_func_t *rl_filename_dequoting_function;
+READLINE_API extern rl_dequote_func_t *rl_filename_dequoting_function;
 
 /* Function to call to decide whether or not a word break character is
    quoted.  If a character is quoted, it does not break words for the
    completer. */
-extern rl_linebuf_func_t *rl_char_is_quoted_p;
+READLINE_API extern rl_linebuf_func_t *rl_char_is_quoted_p;
 
 /* Non-zero means to suppress normal filename completion after the
    user-specified completion function has been called. */
-extern int rl_attempted_completion_over;
+READLINE_API extern int rl_attempted_completion_over;
 
 /* Set to a character describing the type of completion being attempted by
    rl_complete_internal; available for use by application completion
    functions. */
-extern int rl_completion_type;
+READLINE_API extern int rl_completion_type;
 
 /* Character appended to completed words when at the end of the line.  The
    default is a space.  Nothing is added if this is '\0'. */
-extern int rl_completion_append_character;
+READLINE_API extern int rl_completion_append_character;
 
 /* Up to this many items will be displayed in response to a
    possible-completions call.  After that, we ask the user if she
    is sure she wants to see them all.  The default value is 100. */
-extern int rl_completion_query_items;
+READLINE_API extern int rl_completion_query_items;
 
 /* If non-zero, then disallow duplicates in the matches. */
-extern int rl_ignore_completion_duplicates;
+READLINE_API extern int rl_ignore_completion_duplicates;
 
 /* If this is non-zero, completion is (temporarily) inhibited, and the
    completion character will be inserted as any other. */
-extern int rl_inhibit_completion;
+READLINE_API extern int rl_inhibit_completion;
    
 /* Definitions available for use by readline clients. */
 #define RL_PROMPT_START_IGNORE	'\001'
diff -urbBN readline-4.2/rldefs.h readline/rldefs.h
--- readline-4.2/rldefs.h	Wed Nov  8 15:50:32 2000
+++ readline/rldefs.h	Fri Jul 27 17:22:14 2001
@@ -72,6 +72,9 @@
 #if defined (HAVE_STRCASECMP)
 #define _rl_stricmp strcasecmp
 #define _rl_strnicmp strncasecmp
+#elif defined (__MINGW32__)
+#define _rl_stricmp stricmp
+#define _rl_strnicmp strnicmp
 #else
 extern int _rl_stricmp __P((char *, char *);
 extern int _rl_strnicmp __P((char *, char *));
@@ -133,6 +136,27 @@
 #  define FREE(x)	if (x) free (x)
 #endif
 
+#if defined (__MINGW32__)
+#define WAIT_FOR_INPUT 200	/* milliseconds to suspend maximally 
+ 				   when waiting for input */
+#define FOR_INPUT	1	/* flags for open state of the console  */
+#define FOR_OUTPUT	2
+#define INITIALIZED	4
+
+/* undefine this when readline / history should not look into the registry
+   for the path to their init files  */
+#define INITFILES_IN_REGISTRY 1
+ 
+#if defined (INITFILES_IN_REGISTRY)
+/* We also try to get the .inputrc and .history file paths from the registry,
+   define what to look for */
+#define READLINE_REGKEY	"Software\\Free Software Foundation\\libreadline"
+#define INPUTRC_REGVAL	"inputrc-file"
+#define HISTFILE_REGVAL	"history-file"
+#endif
+ 
+#endif	/* __MINGW32__  */
+ 
 /* CONFIGURATION SECTION */
 #include "rlconf.h"
 
diff -urbBN readline-4.2/rlprivate.h readline/rlprivate.h
--- readline-4.2/rlprivate.h	Wed Feb 14 12:43:14 2001
+++ readline/rlprivate.h	Fri Jul 27 18:49:08 2001
@@ -24,6 +24,14 @@
 #if !defined (_RL_PRIVATE_H_)
 #define _RL_PRIVATE_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #include "rlconf.h"	/* for VISIBLE_STATS */
 #include "rlstdc.h"
 #include "posixjmp.h" /* defines procenv_t */
@@ -35,7 +43,7 @@
  *************************************************************************/
 
 /* terminal.c */
-extern char *rl_get_termcap __P((const char *));
+READLINE_API extern char *rl_get_termcap __P((const char *));
 
 /*************************************************************************
  *									 *
@@ -44,23 +52,23 @@
  *************************************************************************/
 
 /* complete.c */
-extern int rl_complete_with_tilde_expansion;
+READLINE_API extern int rl_complete_with_tilde_expansion;
 #if defined (VISIBLE_STATS)
-extern int rl_visible_stats;
+READLINE_API extern int rl_visible_stats;
 #endif /* VISIBLE_STATS */
 
 /* readline.c */
-extern int rl_line_buffer_len;
-extern int rl_arg_sign;
-extern int rl_visible_prompt_length;
-extern int readline_echoing_p;
-extern int rl_key_sequence_length;
+READLINE_API extern int rl_line_buffer_len;
+READLINE_API extern int rl_arg_sign;
+READLINE_API extern int rl_visible_prompt_length;
+READLINE_API extern int readline_echoing_p;
+READLINE_API extern int rl_key_sequence_length;
 
 /* display.c */
-extern int rl_display_fixed;
+READLINE_API extern int rl_display_fixed;
 
 /* parens.c */
-extern int rl_blink_matching_paren;
+READLINE_API extern int rl_blink_matching_paren;
 
 /*************************************************************************
  *									 *
@@ -69,25 +77,25 @@
  *************************************************************************/
 
 /* bind.c */
-extern char *rl_untranslate_keyseq __P((int));
+READLINE_API extern char *rl_untranslate_keyseq __P((int));
 
 /* kill.c */
-extern int rl_set_retained_kills __P((int));
+READLINE_API extern int rl_set_retained_kills __P((int));
 
 /* readline.c */
-extern int rl_discard_argument __P((void));
+READLINE_API extern int rl_discard_argument __P((void));
 
 /* rltty.c */
-extern int rl_stop_output __P((int, int));
+READLINE_API extern int rl_stop_output __P((int, int));
 
 /* terminal.c */
-extern void _rl_set_screen_size __P((int, int));
+READLINE_API extern void _rl_set_screen_size __P((int, int));
 
 /* undo.c */
-extern int _rl_fix_last_undo_of_type __P((int, int, int));
+READLINE_API extern int _rl_fix_last_undo_of_type __P((int, int, int));
 
 /* util.c */
-extern char *_rl_savestring __P((const char *));
+READLINE_API extern char *_rl_savestring __P((const char *));
 
 /*************************************************************************
  *									 *
@@ -107,163 +115,163 @@
 #if defined(READLINE_CALLBACKS)
 
 /* readline.c */
-extern void readline_internal_setup __P((void));
-extern char *readline_internal_teardown __P((int));
-extern int readline_internal_char __P((void));
+READLINE_API extern void readline_internal_setup __P((void));
+READLINE_API extern char *readline_internal_teardown __P((int));
+READLINE_API extern int readline_internal_char __P((void));
 
 #endif /* READLINE_CALLBACKS */
 
 /* bind.c */
-extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
+READLINE_API extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
 
 /* display.c */
-extern char *_rl_strip_prompt __P((char *));
-extern void _rl_move_cursor_relative __P((int, const char *));
-extern void _rl_move_vert __P((int));
-extern void _rl_save_prompt __P((void));
-extern void _rl_restore_prompt __P((void));
-extern char *_rl_make_prompt_for_search __P((int));
-extern void _rl_erase_at_end_of_line __P((int));
-extern void _rl_clear_to_eol __P((int));
-extern void _rl_clear_screen __P((void));
-extern void _rl_update_final __P((void));
-extern void _rl_redisplay_after_sigwinch __P((void));
-extern void _rl_clean_up_for_exit __P((void));
-extern void _rl_erase_entire_line __P((void));
-extern int _rl_current_display_line __P((void));
+READLINE_API extern char *_rl_strip_prompt __P((char *));
+READLINE_API extern void _rl_move_cursor_relative __P((int, const char *));
+READLINE_API extern void _rl_move_vert __P((int));
+READLINE_API extern void _rl_save_prompt __P((void));
+READLINE_API extern void _rl_restore_prompt __P((void));
+READLINE_API extern char *_rl_make_prompt_for_search __P((int));
+READLINE_API extern void _rl_erase_at_end_of_line __P((int));
+READLINE_API extern void _rl_clear_to_eol __P((int));
+READLINE_API extern void _rl_clear_screen __P((void));
+READLINE_API extern void _rl_update_final __P((void));
+READLINE_API extern void _rl_redisplay_after_sigwinch __P((void));
+READLINE_API extern void _rl_clean_up_for_exit __P((void));
+READLINE_API extern void _rl_erase_entire_line __P((void));
+READLINE_API extern int _rl_current_display_line __P((void));
 
 /* input.c */
-extern int _rl_any_typein __P((void));
-extern int _rl_input_available __P((void));
-extern void _rl_insert_typein __P((int));
+READLINE_API extern int _rl_any_typein __P((void));
+READLINE_API extern int _rl_input_available __P((void));
+READLINE_API extern void _rl_insert_typein __P((int));
 
 /* macro.c */
-extern void _rl_with_macro_input __P((char *));
-extern int _rl_next_macro_key __P((void));
-extern void _rl_push_executing_macro __P((void));
-extern void _rl_pop_executing_macro __P((void));
-extern void _rl_add_macro_char __P((int));
-extern void _rl_kill_kbd_macro __P((void));
+READLINE_API extern void _rl_with_macro_input __P((char *));
+READLINE_API extern int _rl_next_macro_key __P((void));
+READLINE_API extern void _rl_push_executing_macro __P((void));
+READLINE_API extern void _rl_pop_executing_macro __P((void));
+READLINE_API extern void _rl_add_macro_char __P((int));
+READLINE_API extern void _rl_kill_kbd_macro __P((void));
 
 /* nls.c */
-extern int _rl_init_eightbit __P((void));
+READLINE_API extern int _rl_init_eightbit __P((void));
 
 /* parens.c */
-extern void _rl_enable_paren_matching __P((int));
+READLINE_API extern void _rl_enable_paren_matching __P((int));
 
 /* readline.c */
-extern void _rl_init_line_state __P((void));
-extern void _rl_set_the_line __P((void));
-extern int _rl_dispatch __P((int, Keymap));
-extern int _rl_init_argument __P((void));
-extern void _rl_fix_point __P((int));
-extern void _rl_replace_text __P((const char *, int, int));
-extern int _rl_char_search_internal __P((int, int, int));
-extern int _rl_set_mark_at_pos __P((int));
-extern int _rl_free_saved_history_line __P((void));
+READLINE_API extern void _rl_init_line_state __P((void));
+READLINE_API extern void _rl_set_the_line __P((void));
+READLINE_API extern int _rl_dispatch __P((int, Keymap));
+READLINE_API extern int _rl_init_argument __P((void));
+READLINE_API extern void _rl_fix_point __P((int));
+READLINE_API extern void _rl_replace_text __P((const char *, int, int));
+READLINE_API extern int _rl_char_search_internal __P((int, int, int));
+READLINE_API extern int _rl_set_mark_at_pos __P((int));
+READLINE_API extern int _rl_free_saved_history_line __P((void));
 
 /* rltty.c */
-extern int _rl_disable_tty_signals __P((void));
-extern int _rl_restore_tty_signals __P((void));
+READLINE_API extern int _rl_disable_tty_signals __P((void));
+READLINE_API extern int _rl_restore_tty_signals __P((void));
 
 /* terminal.c */
-extern void _rl_get_screen_size __P((int, int));
-extern int _rl_init_terminal_io __P((const char *));
+READLINE_API extern void _rl_get_screen_size __P((int, int));
+READLINE_API extern int _rl_init_terminal_io __P((const char *));
 #ifdef _MINIX
-extern void _rl_output_character_function __P((int));
+READLINE_API extern void _rl_output_character_function __P((int));
 #else
-extern int _rl_output_character_function __P((int));
+READLINE_API extern int _rl_output_character_function __P((int));
 #endif
-extern void _rl_output_some_chars __P((const char *, int));
-extern int _rl_backspace __P((int));
-extern void _rl_enable_meta_key __P((void));
-extern void _rl_control_keypad __P((int));
+READLINE_API extern void _rl_output_some_chars __P((const char *, int));
+READLINE_API extern int _rl_backspace __P((int));
+READLINE_API extern void _rl_enable_meta_key __P((void));
+READLINE_API extern void _rl_control_keypad __P((int));
 
 /* util.c */
-extern int rl_alphabetic __P((int));
-extern int _rl_abort_internal __P((void));
-extern char *_rl_strindex __P((const char *, const char *));
-extern char *_rl_strpbrk __P((const char *, const char *));
-extern int _rl_qsort_string_compare __P((char **, char **));
-extern int (_rl_uppercase_p) __P((int));
-extern int (_rl_lowercase_p) __P((int));
-extern int (_rl_pure_alphabetic) __P((int));
-extern int (_rl_digit_p) __P((int));
-extern int (_rl_to_lower) __P((int));
-extern int (_rl_to_upper) __P((int));
-extern int (_rl_digit_value) __P((int));
+READLINE_API extern int rl_alphabetic __P((int));
+READLINE_API extern int _rl_abort_internal __P((void));
+READLINE_API extern char *_rl_strindex __P((const char *, const char *));
+READLINE_API extern char *_rl_strpbrk __P((const char *, const char *));
+READLINE_API extern int _rl_qsort_string_compare __P((char **, char **));
+READLINE_API extern int (_rl_uppercase_p) __P((int));
+READLINE_API extern int (_rl_lowercase_p) __P((int));
+READLINE_API extern int (_rl_pure_alphabetic) __P((int));
+READLINE_API extern int (_rl_digit_p) __P((int));
+READLINE_API extern int (_rl_to_lower) __P((int));
+READLINE_API extern int (_rl_to_upper) __P((int));
+READLINE_API extern int (_rl_digit_value) __P((int));
 
 /* vi_mode.c */
-extern void _rl_vi_initialize_line __P((void));
-extern void _rl_vi_reset_last __P((void));
-extern void _rl_vi_set_last __P((int, int, int));
-extern int _rl_vi_textmod_command __P((int));
-extern void _rl_vi_done_inserting __P((void));
+READLINE_API extern void _rl_vi_initialize_line __P((void));
+READLINE_API extern void _rl_vi_reset_last __P((void));
+READLINE_API extern void _rl_vi_set_last __P((int, int, int));
+READLINE_API extern int _rl_vi_textmod_command __P((int));
+READLINE_API extern void _rl_vi_done_inserting __P((void));
 
 /*************************************************************************
  * Undocumented private variables					 *
  *************************************************************************/
 
 /* bind.c */
-extern const char *_rl_possible_control_prefixes[];
-extern const char *_rl_possible_meta_prefixes[];
+READLINE_API extern const char *_rl_possible_control_prefixes[];
+READLINE_API extern const char *_rl_possible_meta_prefixes[];
 
 /* complete.c */
-extern int _rl_complete_show_all;
-extern int _rl_complete_mark_directories;
-extern int _rl_print_completions_horizontally;
-extern int _rl_completion_case_fold;
+READLINE_API extern int _rl_complete_show_all;
+READLINE_API extern int _rl_complete_mark_directories;
+READLINE_API extern int _rl_print_completions_horizontally;
+READLINE_API extern int _rl_completion_case_fold;
 
 /* display.c */
-extern int _rl_vis_botlin;
-extern int _rl_last_c_pos;
-extern int _rl_suppress_redisplay;
-extern char *rl_display_prompt;
+READLINE_API extern int _rl_vis_botlin;
+READLINE_API extern int _rl_last_c_pos;
+READLINE_API extern int _rl_suppress_redisplay;
+READLINE_API extern char *rl_display_prompt;
 
 /* isearch.c */
-extern unsigned char *_rl_isearch_terminators;
+READLINE_API extern unsigned char *_rl_isearch_terminators;
 
 /* macro.c */
-extern int _rl_defining_kbd_macro;
-extern char *_rl_executing_macro;
+READLINE_API extern int _rl_defining_kbd_macro;
+READLINE_API extern char *_rl_executing_macro;
 
 /* readline.c */
-extern int _rl_horizontal_scroll_mode;
-extern int _rl_mark_modified_lines;
-extern int _rl_bell_preference;
-extern int _rl_meta_flag;
-extern int _rl_convert_meta_chars_to_ascii;
-extern int _rl_output_meta_chars;
-extern char *_rl_comment_begin;
-extern unsigned char _rl_parsing_conditionalized_out;
-extern Keymap _rl_keymap;
-extern FILE *_rl_in_stream;
-extern FILE *_rl_out_stream;
-extern int _rl_last_command_was_kill;
-extern int _rl_eof_char;
-extern procenv_t readline_top_level;
+READLINE_API extern int _rl_horizontal_scroll_mode;
+READLINE_API extern int _rl_mark_modified_lines;
+READLINE_API extern int _rl_bell_preference;
+READLINE_API extern int _rl_meta_flag;
+READLINE_API extern int _rl_convert_meta_chars_to_ascii;
+READLINE_API extern int _rl_output_meta_chars;
+READLINE_API extern char *_rl_comment_begin;
+READLINE_API extern unsigned char _rl_parsing_conditionalized_out;
+READLINE_API extern Keymap _rl_keymap;
+READLINE_API extern FILE *_rl_in_stream;
+READLINE_API extern FILE *_rl_out_stream;
+READLINE_API extern int _rl_last_command_was_kill;
+READLINE_API extern int _rl_eof_char;
+READLINE_API extern procenv_t readline_top_level;
 
 /* terminal.c */
-extern int _rl_enable_keypad;
-extern int _rl_enable_meta;
-extern char *_rl_term_clreol;
-extern char *_rl_term_clrpag;
-extern char *_rl_term_im;
-extern char *_rl_term_ic;
-extern char *_rl_term_ei;
-extern char *_rl_term_DC;
-extern char *_rl_term_up;
-extern char *_rl_term_dc;
-extern char *_rl_term_cr;
-extern char *_rl_term_IC;
-extern int _rl_screenheight;
-extern int _rl_screenwidth;
-extern int _rl_screenchars;
-extern int _rl_terminal_can_insert;
-extern int _rl_term_autowrap;
+READLINE_API extern int _rl_enable_keypad;
+READLINE_API extern int _rl_enable_meta;
+READLINE_API extern char *_rl_term_clreol;
+READLINE_API extern char *_rl_term_clrpag;
+READLINE_API extern char *_rl_term_im;
+READLINE_API extern char *_rl_term_ic;
+READLINE_API extern char *_rl_term_ei;
+READLINE_API extern char *_rl_term_DC;
+READLINE_API extern char *_rl_term_up;
+READLINE_API extern char *_rl_term_dc;
+READLINE_API extern char *_rl_term_cr;
+READLINE_API extern char *_rl_term_IC;
+READLINE_API extern int _rl_screenheight;
+READLINE_API extern int _rl_screenwidth;
+READLINE_API extern int _rl_screenchars;
+READLINE_API extern int _rl_terminal_can_insert;
+READLINE_API extern int _rl_term_autowrap;
 
 /* undo.c */
-extern int _rl_doing_an_undo;
-extern int _rl_undo_group_level;
+READLINE_API extern int _rl_doing_an_undo;
+READLINE_API extern int _rl_undo_group_level;
 
 #endif /* _RL_PRIVATE_H_ */
diff -urbBN readline-4.2/rltty.c readline/rltty.c
--- readline-4.2/rltty.c	Fri Feb  2 18:13:00 2001
+++ readline/rltty.c	Fri Jul 27 17:22:14 2001
@@ -26,6 +26,8 @@
 #  include <config.h>
 #endif
 
+#if !defined (__MINGW32__)	/* for native Win32 environments this is hard stuff  */
+
 #include <sys/types.h>
 #include <signal.h>
 #include <errno.h>
@@ -42,6 +44,10 @@
 #endif /* GWINSZ_IN_SYS_IOCTL */
 
 #include "rltty.h"
+#else	/* __MINGW32__ */
+#include "rldefs.h"
+#include <stdio.h>
+#endif	/* __MINGW32__ */
 #include "readline.h"
 #include "rlprivate.h"
 
@@ -52,6 +58,7 @@
 rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
 rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
 
+#ifndef __MINGW32__
 /* **************************************************************** */
 /*								    */
 /*			   Signal Management			    */
@@ -820,6 +827,115 @@
     }
 #endif /* !NEW_TTY_DRIVER */
 }
+
+#else /* __MING32__ */
+
+/* **************************************************************** */
+/*								    */
+/*		Default Key Bindings for Win32 Console              */
+/*								    */
+/* **************************************************************** */
+
+#include <windows.h>
+
+#define CONSOLE_MODE	ENABLE_PROCESSED_INPUT | ENABLE_MOUSE_INPUT
+
+/* global vars used by other modules */
+
+int	haveConsole	= 0;	/* remember init result of the console  */
+HANDLE	hStdout, hStdin;	/* these are different from stdin, stdout  */
+
+COORD	rlScreenOrigin;		/* readline origin in frame buffer coordinates */
+int	rlScreenStart = 0;	/* readline origin as frame screen buffer offset */
+COORD	rlScreenEnd;		/* end of line in frame buffer coordinates */
+int	rlScreenMax = 0;	/* end of line as linear frame buffer offset */
+
+static DWORD savedConsoleMode = 0;	/* to restore console on exit */
+
+void
+rltty_set_default_bindings (kmap)
+     Keymap kmap;
+{
+  /* I bet this is required on Win32 ;-) */
+  {
+    char buf[40]; strcpy(buf,"set bell-style none");
+    rl_parse_and_bind(buf);
+  }
+  rl_set_key ("\\M-\\ø&", rl_get_previous_history, kmap);
+  rl_set_key ("\\M-\\ø(", rl_get_next_history, kmap);
+  rl_set_key ("\\M-\\ø'", rl_forward, kmap);
+  rl_set_key ("\\M-\\ø%", rl_backward, kmap);
+  
+  rl_set_key ("\\M-\\ø$", rl_beg_of_line, kmap);
+  rl_set_key ("\\M-\\ø#", rl_end_of_line, kmap);
+  rl_set_key ("\\M-\\ú%", rl_backward_word, kmap);
+  rl_set_key ("\\M-\\ú'", rl_forward_word, kmap);
+  
+  rl_set_key ("\\M-\\ù-", rl_paste_from_clipboard, kmap);
+  rl_set_key ("\\M-\\ø.", rl_delete, kmap);
+  rl_set_key ("", rl_unix_word_rubout, kmap);
+}
+
+/* Query and set up a Window Console */
+
+void
+rl_prep_terminal (meta_flag)
+     int meta_flag;
+{
+  readline_echoing_p = 1;
+  
+  if ( !(haveConsole & INITIALIZED) )
+    {
+      if ( !(haveConsole & FOR_INPUT)
+	   && ((hStdin = GetStdHandle(STD_INPUT_HANDLE)) != INVALID_HANDLE_VALUE) )
+        {
+          DWORD dummy;
+          INPUT_RECORD irec;
+          if ( PeekConsoleInput(hStdin, &irec, 1, &dummy) )
+            {
+              haveConsole |= FOR_INPUT;
+              if ( GetConsoleMode(hStdin, &savedConsoleMode) )
+                SetConsoleMode(hStdin, CONSOLE_MODE);
+            }
+        }
+      if ( (hStdout = GetStdHandle(STD_OUTPUT_HANDLE)) != INVALID_HANDLE_VALUE)
+        {
+          CONSOLE_SCREEN_BUFFER_INFO csbi;
+          if ( GetConsoleScreenBufferInfo(hStdout, &csbi) 
+               && (csbi.dwSize.X > 0) && (csbi.dwSize.Y > 0) )
+            {
+              haveConsole |= FOR_OUTPUT;
+              rlScreenOrigin = csbi.dwCursorPosition;
+              rlScreenStart = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+		+ (int)csbi.dwCursorPosition.X;
+            }
+        }
+      haveConsole |= INITIALIZED;
+    }
+}
+
+/* Restore the consoles's normal settings and modes. */
+void
+rl_deprep_terminal ()
+{
+  SetConsoleMode(hStdin, savedConsoleMode);
+  haveConsole = 0;
+}
+
+int
+rl_restart_output (count, key)
+     int count, key;
+{
+  return 0;
+}
+
+int
+rl_stop_output (count, key)
+     int count, key;
+{
+  return 0;
+}
+#endif /* __MINGW32__ */
 
 /* New public way to set the system default editing chars to their readline
    equivalents. */
diff -urbBN readline-4.2/rltty.h readline/rltty.h
--- readline-4.2/rltty.h	Thu Aug  5 14:12:46 1999
+++ readline/rltty.h	Fri Jul 27 17:22:14 2001
@@ -38,7 +38,7 @@
 #endif /* TERMIO_TTY_DRIVER */
 
 /* Other (BSD) machines use sgtty. */
-#if defined (NEW_TTY_DRIVER)
+#if defined (NEW_TTY_DRIVER) && !defined (__MINGW32__)
 #  include <sgtty.h>
 #endif
 
diff -urbBN readline-4.2/shell.c readline/shell.c
--- readline-4.2/shell.c	Wed Nov  8 17:12:44 2000
+++ readline/shell.c	Fri Jul 27 17:42:50 2001
@@ -45,7 +45,11 @@
 #endif /* !HAVE_STRING_H */
 
 #include <fcntl.h>
+#ifndef __MINGW32__
 #include <pwd.h>
+#else
+#include <windows.h>
+#endif
 
 #include <stdio.h>
 
@@ -132,12 +136,16 @@
 sh_get_home_dir ()
 {
   char *home_dir;
+#ifndef __MINGW32__
   struct passwd *entry;
 
   home_dir = (char *)NULL;
   entry = getpwuid (getuid ());
   if (entry)
     home_dir = entry->pw_dir;
+#else
+  home_dir = sh_get_env_value ("HOME");
+#endif
   return (home_dir);
 }
 
@@ -147,6 +155,7 @@
 #  endif
 #endif
 
+#ifndef __MINGW32__
 int
 sh_unset_nodelay_mode (fd)
      int fd;
@@ -174,3 +183,30 @@
 
   return 0;
 }
+
+#else	/* __MINGW32__  */
+char *
+get_user_registry_string(char *keyName, char* valName)
+{
+  char *result = NULL;
+  HKEY	subKey;
+  if ( keyName && (RegOpenKeyEx(HKEY_CURRENT_USER, keyName, 0, KEY_READ, &subKey)
+                   == ERROR_SUCCESS) )
+    {
+      DWORD type;
+      char *chtry = NULL;
+      DWORD bufSize = 0;
+      
+      if ( (RegQueryValueExA(subKey, valName, NULL, &type, chtry, &bufSize)
+	    == ERROR_SUCCESS) && (type == REG_SZ) )
+        {
+	  if ( (chtry = (char *)xmalloc(bufSize))
+	       && (RegQueryValueExA(subKey, valName, NULL, &type, chtry, &bufSize) 
+		   == ERROR_SUCCESS) )
+	    result = chtry;
+        }
+    }
+  return result;
+}
+#endif	/* __MINGW32__  */
+
diff -urbBN readline-4.2/signals.c readline/signals.c
--- readline-4.2/signals.c	Tue Dec 12 20:01:44 2000
+++ readline/signals.c	Fri Jul 27 17:22:14 2001
@@ -73,7 +73,9 @@
 #  define sigemptyset(m)
 #endif /* !HAVE_POSIX_SIGNALS */
 
+#ifndef __MINGW32__
 static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
+#endif
 
 /* Exported variables for use by applications. */
 
@@ -89,6 +91,7 @@
 static int signals_set_flag;
 static int sigwinch_set_flag;
 
+#ifndef __MINGW32__
 /* **************************************************************** */
 /*					        		    */
 /*			   Signal Handling                          */
@@ -354,6 +357,7 @@
 
   return 0;
 }
+#endif /* !__MINGW32__ */
 
 /* Clean up the terminal and readline state after catching a signal, before
    resending it to the calling application. */
@@ -394,4 +398,50 @@
   _rl_init_argument ();
 }
 
+#if defined (__MINGW32__)
+
+#include <windows.h>
+#include <signal.h>
+#include <stdio.h>
+
+/* Handling of CTRL_C_EVENT, CTRL_CLOSE_EVENT, CTRL_BREAK_EVENT, 
+ * CTRL_LOGOFF_EVENT, CTRL_SHUTDOWN_EVENT,
+ * WINDOW_BUFFER_SIZE_EVENTs are handled separately see input.c
+ */
+
+BOOL CtrlEventHandler(DWORD dwEventType)
+{
+  if (dwEventType == CTRL_C_EVENT)
+    rl_free_line_state ();
+  rl_cleanup_after_signal ();
+  if (dwEventType == CTRL_C_EVENT)	/* special treatment */
+    {
+      if (rl_catch_signals == 1)	/* > 1: handled only locally */
+	{
+	  raise(SIGINT);		/* pass to program signal hadler */
+	  rl_reset_after_signal();	/* on return goon */
+	}
+      return TRUE;			/* don't pass to upstream handlers */
+    }
+  return FALSE; 			/* pass other events to handler chain */
+}
+
+int
+rl_set_signals ()
+{
+  if (rl_catch_signals && signals_set_flag == 0)
+    signals_set_flag = SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlEventHandler, TRUE);
+  return signals_set_flag;
+}
+
+int
+rl_clear_signals ()
+{
+  if ( signals_set_flag )
+    if ( SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlEventHandler, FALSE) )
+      signals_set_flag = 0;
+  return signals_set_flag;
+}
+
+#endif	/* __MINGW32__  */
 #endif  /* HANDLE_SIGNALS */
diff -urbBN readline-4.2/terminal.c readline/terminal.c
--- readline-4.2/terminal.c	Tue Feb  6 20:39:22 2001
+++ readline/terminal.c	Fri Jul 27 20:08:24 2001
@@ -51,9 +51,17 @@
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
+#if defined (__MINGW32__)
+# include <windows.h>
+extern int haveConsole;	/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD	rlScreenEnd;
+extern int	rlScreenMax;
+#else /* !__MINGW32__ */
 #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
 #  include <sys/ioctl.h>
 #endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
+#endif
 
 #include "rltty.h"
 #include "tcap.h"
@@ -71,10 +79,12 @@
 /*								    */
 /* **************************************************************** */
 
+#ifndef __MINGW32__
 static char *term_buffer = (char *)NULL;
 static char *term_string_buffer = (char *)NULL;
 
 static int tcap_initialized;
+#endif
 
 #if !defined (__linux__)
 #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
@@ -169,6 +179,7 @@
    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
    non-null serve to check whether or not we have initialized termcap. */
+#ifndef __MINGW32__
 void
 _rl_get_screen_size (tty, ignore_env)
      int tty, ignore_env;
@@ -234,6 +245,28 @@
   _rl_screenchars = _rl_screenwidth * _rl_screenheight;
 }
 
+#else	/* __MINGW32__*/
+
+void
+_rl_get_screen_size (tty, ignore_env)
+     int tty, ignore_env;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      _rl_screenwidth = csbi.dwSize.X;
+      _rl_screenheight = csbi.dwSize.Y;
+    }
+  else
+    {
+      _rl_screenwidth = 80;
+      _rl_screenheight = 24;
+    }
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+}
+#endif	/* __MINGW32__  */
+
 void
 _rl_set_screen_size (rows, cols)
      int rows, cols;
@@ -277,6 +310,7 @@
     }
 }
 
+#ifndef __MINGW32__
 struct _tc_string {
      const char *tc_var;
      char **tc_value;
@@ -330,6 +364,7 @@
 #endif
   tcap_initialized = 1;
 }
+#endif /* __MINGW32__ */
 
 #define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
 #define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
@@ -338,6 +373,31 @@
 _rl_init_terminal_io (terminal_name)
      const char *terminal_name;
 {
+#ifdef __MINGW32__
+  _rl_term_cr = "\r";						/* any value != 0  */
+  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;	/* !! we emulate insertion  */
+  _rl_term_up = "y";						/* any value != 0  */
+  _rl_term_dc = _rl_term_DC =  (char *)NULL;			/* !! we emulate deletion  */
+  _rl_visible_bell = (char *)NULL;
+ 
+  _rl_get_screen_size (0, 1);
+   
+  /* Let Windows handle meta keys!  */
+  term_has_meta = 0;
+  _rl_term_mm = _rl_term_mo = (char *)NULL;
+ 
+  /* It probably has arrow keys, but I don't know what they are. */
+  _rl_term_ku = _rl_term_kd = _rl_term_kr = _rl_term_kl = (char *)NULL;
+  
+#if defined (HACK_TERMCAP_MOTION)
+  _rl_term_forward_char = (char *)NULL;
+#endif /* HACK_TERMCAP_MOTION */
+ 
+  _rl_terminal_can_insert = 0;
+  _rl_term_autowrap = 1;
+
+#else /* !__MINGW32__ */
+
   const char *term;
   char *buffer;
   int tty, tgetent_ret;
@@ -401,7 +461,7 @@
       _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
       _rl_term_mm = _rl_term_mo = (char *)NULL;
 #if defined (HACK_TERMCAP_MOTION)
-      term_forward_char = (char *)NULL;
+      _rl_term_forward_char = (char *)NULL;
 #endif
       _rl_terminal_can_insert = term_has_meta = 0;
 
@@ -468,9 +528,11 @@
 
   _rl_keymap = xkeymap;
 
+#endif /* !__MINGW32__ */
   return 0;
 }
 
+#ifndef __MINGW32__
 char *
 rl_get_termcap (cap)
      const char *cap;
@@ -486,6 +548,7 @@
     }
   return ((char *)NULL);
 }
+#endif
 
 /* Re-initialize the terminal considering that the TERM/TERMCAP variable
    has changed. */
@@ -497,6 +560,7 @@
   return 0;
 }
 
+#ifndef __MINGW32__
 /* A function for the use of tputs () */
 #ifdef _MINIX
 void
@@ -579,6 +643,80 @@
   return (-1);
 }
 
+#else	/* __MINGW32__ */
+
+/* Write COUNT characters from STRING to the output stream. */
+void
+_rl_output_some_chars (string, count)
+     const char *string;
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  fwrite (string, 1, count, _rl_out_stream);
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      int linear_pos = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+			+ (int)csbi.dwCursorPosition.X;
+      if (linear_pos > rlScreenMax)
+        {
+          rlScreenEnd = csbi.dwCursorPosition;
+          rlScreenMax = linear_pos;
+        }
+    }
+}
+
+/* This is used to collect all putc output */
+int
+_rl_output_character_function (c)
+     int c;
+{
+  _rl_output_some_chars ((char *)&c, 1);
+  return 1;
+}
+
+/* Move the cursor back. */
+int
+_rl_backspace (count)
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      while (count > csbi.dwCursorPosition.X)
+        {
+          --csbi.dwCursorPosition.Y;
+          count -= csbi.dwCursorPosition.X + 1;
+          csbi.dwCursorPosition.X = csbi.dwSize.X - 1;
+        }
+      csbi.dwCursorPosition.X -= count;
+      SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition);
+    }
+  return 0;
+}
+
+/* Move to the start of the next line. */
+int
+rl_crlf ()
+{
+  _rl_output_some_chars ("\n", 1);
+  return 0;
+}
+
+/* Ring the terminal bell. */
+int
+rl_ding ()
+{
+  if (readline_echoing_p)
+    {
+      if (_rl_bell_preference != NO_BELL)
+	MessageBeep(MB_OK);
+      return (0);
+    }
+  return (-1);
+}
+#endif	/* __MINGW32__ */
+
 /* **************************************************************** */
 /*								    */
 /*	 	Controlling the Meta Key and Keypad		    */
@@ -588,7 +726,7 @@
 void
 _rl_enable_meta_key ()
 {
-#if !defined (__DJGPP__)
+#if !defined (__DJGPP__) && !defined (__MINGW32__)
   if (term_has_meta && _rl_term_mm)
     tputs (_rl_term_mm, 1, _rl_output_character_function);
 #endif
@@ -598,7 +736,7 @@
 _rl_control_keypad (on)
      int on;
 {
-#if !defined (__DJGPP__)
+#if !defined (__DJGPP__) && !defined (__MINGW32__)
   if (on && _rl_term_ks)
     tputs (_rl_term_ks, 1, _rl_output_character_function);
   else if (!on && _rl_term_ke)
diff -urbBN readline-4.2/tilde.c readline/tilde.c
--- readline-4.2/tilde.c	Wed Feb 14 22:04:20 2001
+++ readline/tilde.c	Fri Jul 27 18:04:24 2001
@@ -43,7 +43,11 @@
 #endif /* HAVE_STDLIB_H */
 
 #include <sys/types.h>
+#ifndef __MINGW32__
 #include <pwd.h>
+#else
+#include <windows.h>
+#endif
 
 #include "tilde.h"
 
@@ -304,7 +308,12 @@
 {
   char *dirname, *expansion, *username;
   int user_len;
+#ifndef __MINGW32__
   struct passwd *user_entry;
+#else
+  char UserName[256];
+  unsigned long UserLen = 256;
+#endif
 
   if (filename == 0)
     return ((char *)NULL);
@@ -345,6 +354,7 @@
   /* No preexpansion hook, or the preexpansion hook failed.  Look in the
      password database. */
   dirname = (char *)NULL;
+#ifndef __MINGW32__
   user_entry = getpwnam (username);
   if (user_entry == 0)
     {
@@ -372,6 +382,16 @@
     }
 
   endpwent ();
+#else /* __MINGW32__ */
+  if (GetUserName (UserName, &UserLen))
+    {
+      if (!stricmp (username, UserName))
+	dirname = glue_prefix_and_suffix (sh_get_home_dir (), filename, user_len);
+      else if (dirname == 0)
+	dirname = savestring (filename);
+    }
+  free (username);
+#endif
   return (dirname);
 }
 
diff -urbBN readline-4.2/tilde.dsp readline/tilde.dsp
--- readline-4.2/tilde.dsp	Thu Jan  1 01:00:00 1970
+++ readline/tilde.dsp	Fri Jul 27 17:22:14 2001
@@ -0,0 +1,69 @@
+# Microsoft Developer Studio Project File - Name="tilde" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 5.00
+# ** NICHT BEARBEITEN **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=tilde - Win32 Debug
+!MESSAGE Dies ist kein gültiges Makefile. Zum Erstellen dieses Projekts mit\
+ NMAKE
+!MESSAGE verwenden Sie den Befehl "Makefile exportieren" und führen Sie den\
+ Befehl
+!MESSAGE 
+!MESSAGE NMAKE /f "tilde.mak".
+!MESSAGE 
+!MESSAGE Sie können beim Ausführen von NMAKE eine Konfiguration angeben
+!MESSAGE durch Definieren des Makros CFG in der Befehlszeile. Zum Beispiel:
+!MESSAGE 
+!MESSAGE NMAKE /f "tilde.mak" CFG="tilde - Win32 Debug"
+!MESSAGE 
+!MESSAGE Für die Konfiguration stehen zur Auswahl:
+!MESSAGE 
+!MESSAGE "tilde - Win32 Debug" (basierend auf\
+  "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Dbg"
+# PROP Intermediate_Dir "Dbg"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "." /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "__MINGW32__" /D __STDC__=0 /D "HAVE_CONFIG_H" /D "TEST" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x407 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib advapi32.lib /nologo /version:4.1 /subsystem:console /pdb:none /debug /machine:I386
+# Begin Target
+
+# Name "tilde - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\shell.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\tilde.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\xmalloc.c
+# End Source File
+# End Target
+# End Project
diff -urbBN readline-4.2/tilde.h readline/tilde.h
--- readline-4.2/tilde.h	Mon Oct 30 19:31:04 2000
+++ readline/tilde.h	Fri Jul 27 19:00:28 2001
@@ -28,6 +28,14 @@
 extern "C" {
 #endif
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 /* A function can be defined using prototypes and compile on both ANSI C
    and traditional C compilers with something like this:
 	extern char *func __P((char *, char *, int)); */
@@ -58,30 +66,30 @@
    wants called before trying the standard tilde expansions.  The function
    is called with the text sans tilde, and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if the expansion fails. */
-extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
+READLINE_API extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
 
 /* If non-null, this contains the address of a function to call if the
    standard meaning for expanding a tilde fails.  The function is called
    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if there is no expansion. */
-extern tilde_hook_func_t *tilde_expansion_failure_hook;
+READLINE_API extern tilde_hook_func_t *tilde_expansion_failure_hook;
 
 /* When non-null, this is a NULL terminated array of strings which
    are duplicates for a tilde prefix.  Bash uses this to expand
    `=~' and `:~'. */
-extern char **tilde_additional_prefixes;
+READLINE_API extern char **tilde_additional_prefixes;
 
 /* When non-null, this is a NULL terminated array of strings which match
    the end of a username, instead of just "/".  Bash sets this to
    `:' and `=~'. */
-extern char **tilde_additional_suffixes;
+READLINE_API extern char **tilde_additional_suffixes;
 
 /* Return a new string which is the result of tilde expanding STRING. */
-extern char *tilde_expand __P((const char *));
+READLINE_API extern char *tilde_expand __P((const char *));
 
 /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
-extern char *tilde_expand_word __P((const char *));
+READLINE_API extern char *tilde_expand_word __P((const char *));
 
 #ifdef __cplusplus
 }
diff -urbBN readline-4.2/util.c readline/util.c
--- readline-4.2/util.c	Wed Feb 14 12:43:18 2001
+++ readline/util.c	Fri Jul 27 17:22:14 2001
@@ -244,7 +244,7 @@
   return ((char *)NULL);
 }
 
-#if !defined (HAVE_STRCASECMP)
+#if !defined (HAVE_STRCASECMP) && !defined (__MINGW32__)
 /* Compare at most COUNT characters from string1 to string2.  Case
    doesn't matter. */
 int
